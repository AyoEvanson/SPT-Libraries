{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"setup.html","title":"Setup","text":"<p>These libraries go hand-in-hand with the VFFS Demo PLC.</p> <p>This sample is created by Beckhoff Automation LLC., and is provided as-is under the Zero-Clause BSD license.</p>"},{"location":"setup.html#how-to-get-support","title":"How to get support","text":"<p>For SPT framework support, raise an issue here.</p> <p>For general TwinCAT and Beckhoff Product support, please contact your local Beckhoff Support.</p>"},{"location":"setup.html#adding-this-repo-as-a-twincat-plc-library-repository","title":"Adding this repo as a TwinCAT PLC Library Repository","text":"<p>1) Clone this repository to your PC</p> <p>2) Open the Library Repository</p> <p></p> <p>3) Click Edit Locations...</p> <p></p> <p>4) Click Add...</p> <p></p> <p>5) Browse to the folder where you cloned this repository and give the PLC Library Repository a name (e.g. SPT Libraries).  NOTE The location MUST point to the \\Library Repository folder under the repo root!</p> <p></p> <p>6) Future updates to the SPT libraries will automatically propogate into TwinCAT XAE by fetching this repo.</p>"},{"location":"DesignGuide/index.html","title":"Design Guide","text":""},{"location":"DesignGuide/index.html#overall-layout","title":"Overall Layout","text":"<p>The ideal approach is to have program components that are standardized, easily transferred to different machines, flexible enough to be customized and modified, and re-usable so that core components can be readily re-used amongst multiple machines and allow for future updates.  </p> There is no one single \u201cright way\u201d to write code <p>There are however many best practices and different design approaches for writing software, the key item is consistency, when all programmers in a group follow the same approach to writing code, code is more readable, re-usable, and robust.  Software development has not changed much since its inception.  Software development tools have gotten a lot better and easier to use but base concepts such as Object-Oriented Programming have not changed since its creation in the 1960\u2019s.  The problem is many of these ideas and tools passed the PLC world by until now, now the PLC world is catching up. Cabinet designers and mechanical designers are very familiar with revision control.  Checking parts of drawings out, editing them and checking back in is common practice. These processes originated in the programming world, and they were so successful, drawing packages have implemented them.  PLC Software development tools now have these same capabilities (often free of charge) that the rest of the programming world has had for decades.  Take advantage of these tools.  The aim of this document is to present a few different ways how things can be done.  It is up to the individual companies/teams to decide which ideas (if any) they like and will implement.  PLC software development is no different to any other software development and it should be treated as such.  All the tools available to the software development world are also available for PLC software development.  When code is written in a consistent documented manner it will be easier to read, easier to modify, easier to re-use and easier to update.  This saves money. </p>"},{"location":"DesignGuide/index.html#plan-the-code","title":"Plan the code","text":"<p>Very few physical things are built by trial and error, not unless there is lots of material to destroy and time to rebuild.  So why does it happen with software?  No one would ever say to the mechanical department, \u201cHey we've had some steel here for an hour someone should start building the frame.  At least put the feet on the frame, we know the machine will need feet, that can be done right now, you weld those feet on to that beam\u201d.   Everything is first planned, then built, after that, it mostly fits together and there is very little re-work.  No plan? Then in the beginning lots of things get built, it looks like progress is fantastic as things are being completed, but when it\u2019s time to bring them together, they don't fit and they must be re-built and re-worked and all that perceived progress is gone, lots of time and material is wasted re-doing things.  Code is no different, the more complete the plan the less re-work later.  </p>"},{"location":"DesignGuide/index.html#layers-and-interfaces","title":"Layers and interfaces","text":"<p>Everything, absolutely everything is accomplished via smaller components that work together.  Break down any problem into small manageable complete pieces. Components interact with each other in layers via interfaces.  Banking and bank machines are a perfect example.  There are three layers.  Customer, Bank Machine, and the Bank\u2019s Account Database.  The three talk to each other via interfaces.  An interface is the simply the common connection at the boundary between two components.  Where each component can say, \u201cMy responsibility ends at the interface\u201d or \u201cYou don\u2019t get to see anything past the interface\u201d.  The interface between the bank machine and the customer consists of a bankcard and a pin.  To take money out, a customer puts the card into the machine and enters a pin. The bank machine\u2019s interface to the bank is a secure network connection.  Via the network connection the bank machine provides the account number, pin and how much money has been requested.  The bank verifies the account, pin, and availability of funds.  If funds are available, the bank tells the bank machine to go ahead and release the money.  The bank machine counts the money, presents the money, confirms the user has taken the money and tells the bank to update the balance.  Any bankcard and pin, any bank machine, any bank, it all works. Pesos, Dollars, Euro it does not matter, the interfaces are clear, well defined, and everything interchangeable.   </p>"},{"location":"DesignGuide/index.html#interfaces-allow-for-exchange","title":"Interfaces allow for Exchange","text":"<p>A key component of Interfaces is that they allow a component to be exchanged without affecting the other side.  Take for example a car.  The interface for using a car is the steering wheel, gas pedal, and brake pedal.  Every licensed operator can use this interface, what goes on past that, does not matter, and should not concern the user.  A diesel car can be exchanged for a gasoline or electric car, and it does not matter any, any operator can drive the car.  When the interface is different, such as manual gearbox with a clutch, then not every operator can use, only operators that understand the extra interface can use the car.  </p> <p>The same works in machines, developing controls or modules with interfaces allows components to be exchanged without affecting other parts of the machine.  Easier exchange of modules allows for more options with lower engineering costs and less risk.  </p> <p>Code should always be written in such a way that there is a defined interface to separate the inside of a piece of code from the outside.  Interfaces should be as similar as possible.  This makes it easier to change things later.  If the interface to the car was to directly adjust the carburetor's fuel/air mix, then switching to an electric car is going to be significantly more work as the interface between the engines is drastically different.  </p>"},{"location":"DesignGuide/index.html#machine-built-from-layers-and-interfaces","title":"Machine Built from Layers and Interfaces","text":"<p>A machine can be programmed in single block of code.  It will be a nightmare to maintain, making adjustments will break existing functions, and virtually none of the code would be re-usable.  Every machine built in this manner starts from scratch.  Programming, as with any problem, is best solved by breaking it down into manageable pieces.  Dividing a problem into layers allows for abstraction (interchangeable parts), and breaking components up into various pieces makes it easier for multiple programmers to handle simultaneously.   Smaller components are more likely to be re-used.  Three levels appear to be about right number.  Machine, Equipment Module, Component.  The machine coordinates multiple Equipment Modules.  Equipment Modules coordinate multiple Components, and Components are made up of a series of base components where each performs a single specific function.</p> <p> </p> Code Hierarchy"},{"location":"DesignGuide/index.html#abstraction","title":"Abstraction","text":"<p>One of the key reasons for having layers is abstraction.  This is the idea of \"I don't need to know how\" or \"I don't want to know how X works I just need it to go\".  For the car, \"I push on the gas pedal for the car to go\".  I do not care how it goes; my job is to deliver the pizza not to figure out how to burn fuel to turn the wheels. This is abstraction; nothing past the interface concerns me if it does what the interface says it will.  Give me a car and I will deliver the pizza.  It is up to the people building and maintaining the car to ensure that when the gas pedal is pressed, the car will go.  For the machine to \u201cdo something\u201d, it will issue commands to the Equipment Modules in whatever order is required for the machine to operate.  The machine also responds to the status of the Equipment Modules, if an equipment module has a problem, the machine will determine what all other Equipment Modules must do.  The machine only must deal with Equipment Modules.  The machine does not care which or how many Components the Equipment Modules have.   Equipment Modules can be exchanged for other Equipment Modules and the machine can deal with this easily.</p> <p>Abstraction can make things very efficient.  If all Equipment Modules have the same interface, IE they accept the same commands and return the same status, then equipment modules become interchangeable.  For example, A company has built two Unwind Equipment Modules, one using Servo Motors and one using DC motors, provided both Unwind Equipment Modules use the same interface, one can be replaced with the other without any changes to the programming of the machine.  The machine programmer can focus on coordinating the modules to make everything run, rather than wasting time figuring out how to get a module to perform its function.  </p> <p>Equipment Modules work with Components in the same way.  The Equipment Modules coordinate the Components to perform a machine function. The Equipment Module issues commands to the Components and monitors the status of the Components to perform the function requested by the Machine.  </p> <p> </p> Communication Between Layers <p>Interfaces between layers should be as standardized as possible.  For example, all axis\u2019 should have the same commands and status.  It would make no sense to have some axis to use the command <code>Reset()</code> to clear faults and another axis to use the function <code>ClearError()</code>.  It is far faster and simpler to build an Equipment Module if the Components have similar commands and status and it is faster and simpler to build the Machine if Equipment Modules have similar interfaces.</p>"},{"location":"DesignGuide/index.html#implementing-interfaces","title":"Implementing Interfaces","text":"<p>There are many ways to implement interfaces, things like Variables, Methods, and Properties, but there is no single right way.  All roads lead to Rome.  The most important item is consistency.  All roads might lead to Rome, but planes, trains and cars do not mix.  Code should be written with the expectation that someone else (a user) will take the completed component and implement it.  The \u201cuser\u201d never has to look inside a component to have to get it to work.  If a user must look inside a block to figure out how to use it, the user will generally throw the block out and write a new one.  This new block now must be tested and debugged, a huge waste of time and money. Command Structures, Status Structures, Error Messages and Variable Naming should all be consistent between levels/modules.  Exceptions to the standard, or blocks of code that behave differently require more time to implement, have more errors, take more time to debug/commission, are less likely to be re-used, and at the end of the day cost more money. </p>"},{"location":"DesignGuide/index.html#getting-started-machine-vs-equipment-module-vs-component","title":"Getting Started - Machine vs Equipment Module vs Component","text":""},{"location":"DesignGuide/index.html#where-does-one-module-end-and-another-begin","title":"Where does one module end and another begin?","text":"<p>Determining what each level will do takes some time and must be well thought out.  This is the core design, think it through, time spent here saves time later.  </p> <p>What happens when the layers are not well defined, or the interface is not clear?</p> <p>Back to the Bank Machine example, there is an easy way to build a bank machine.  Take a box of money, embed it in concrete and put a bunch of unlocked combination locks next to it. Give the serial numbers and combinations of the locks to the bank.  To use the \u201cbank box\u201d.  The user goes to the \u201cbank box\u201d and phones the bank.  The user gives the bank their account number, pin, the serial number of the combination lock currently on the \u201cbank box\u201d, and how much money they want to withdraw.  The bank looks up how much money is in the box; how much money is in the account and says OK here is the combination to that lock.  Take your money, then take a new lock, and put it on the box.  The bank then subtracts the amount of money the user told them from their account balance and updates how much money is left in the box.  When the bank finally gets around to putting more money in the \u201cBank Box\u201d the balance will almost certainly be wrong.  At which point the \u201cBank Box Company\u201d says, \u201cIt\u2019s not my fault the user took out more money than they said they did, they didn't use it as described in the terms and conditions\"  When the components or layers are not properly defined and the responsibility of tasks is not correctly assigned, the phrase: \u201cX works fine, they didn\u2019t use X correctly\u201d is commonly heard.  If this is happening, either it is not clear how to use the interface, or the user of the component is performing tasks that the component should do itself. In the \u201cBank Box\u201d machine example the user and the bank are doing the \"Bank Box\u2019s\u201d tasks.   </p>"},{"location":"DesignGuide/index.html#figuring-out-which-block-is-responsible-for-what-is-important","title":"Figuring out which block is responsible for what is important.","text":"<p>The problem \u201cyou are not supposed to take out more money than you said you would\u201d is easy to avoid when the bank box is responsible for dispensing the money and keeping track how much money is in the box.  After a bit of examination, anything happening inside the box should be the boxes responsibility.  The user should never be able to \"see inside\".  The Bank should not have to keep track of how much money remains in the box before approving the withdrawal.  The bank is worried about how much money is in the bank, not the box.  If the user needs to look inside the component to use the component, the interface is incomplete.  If someone needs to know how much money is in the box, the box should keep track of this and provide this value in the interface.  If the user needs to provide external logic/functionality to get the block to do what it is supposed to, the functionally is incomplete and tasks need to be re-assigned. </p>"},{"location":"DesignGuide/index.html#what-should-each-layer-do","title":"What should each layer do?","text":""},{"location":"DesignGuide/index.html#base-components-components","title":"Base Components / Components","text":"<p>Components are individual devices that perform a task, but they do perform a \u201cMachine function\u201d.  For example, a solenoid can move forward and back, and axis can spin and stop at a position, but these things are not a machine function.  An Equipment Module will implement Components such as Axis and Solenoids together with sensors, and other devices to perform a machine function such as a \u201cBack Gauge\u201d or \u201cUnwinder\u201d \u201cUnloader or \u201cFiller\u201d </p> <p>Components must be usable by any Equipment Module.  EG The Axis Component.  The Equipment Module function \u201cMove Back Gauge\u201d is implemented by commanding an \u201cAxis Component\u201d to go to a specific position.  The Axis Component itself has no idea that it is controlling a Back Gauge or a Spindle or a Tension Roller, it simply has commands like \u201cgo to position X\u201d The Equipment Module defines that this Axis Component is driving a Back Gauge. </p> <p>Only Components talk to Hardware. Why? Abstraction.  If only the Components talk to hardware, hardware can be replaced/exchanged without having to re-write the Equipment Module.  If a DC motor Component has the same interface and functions as a Servo motor Component, then inside the Equipment Module one can be swapped for the other without making any coding changes to the Equipment Module.  The Equipment Module\u2019s only concern is the command \u201cGo to position X\u201d results in the Position X being reached. Servo may be faster and more precise, but so long as it goes to position X, the Equipment Module doesn\u2019t care about the \u201cHow\u201d.  </p>"},{"location":"DesignGuide/index.html#equipment-module-level","title":"Equipment Module Level","text":"<p>Equipment Modules, this is the important one, but it is also usually a more obvious one.  The machine will be set up mechanically into individual modules.  It is important to get the Equipment Module level right.   If the Equipment Module is too low level, it is like driving the car by adjusting the airflow and fuel injection.  The Machine level is doing things best done by the Equipment Module. Too high of a level and the Equipment Modules is doing too much work that the Machine should be doing. The car is doing everything including the navigation.  One key to getting Equipment Modules correct is; If this module is removed from the machine, which components need to be included to dry cycle it?  Can this module perform its function without other components?  Can it be removed or replaced?  An equipment module should perform a specific but complete function.  An Equipment Module should not talk directly to hardware.  It might need a sensors value and status, but a Component should be scaling the sensors value and monitoring the sensor to determine if the value is in an error range.   A system can have as many Equipment Modules as it needs. Equipment modules might be simple, or they might be complex.  </p>"},{"location":"DesignGuide/index.html#machine-level","title":"Machine Level","text":"<p>Determining the scope of the machine level is straightforward, it is the top layer, and it is what drives all other components.  When a machine is provided with materials, it can complete its entire function. The machine however is not just the Main Program.  The machine will have to talk to an operator.  The Human Machine Interface (HMI) or Operator Interface is often a GUI (Graphical User Interface), but it does not need to be.  The Operator interface could be a push button and a light.  Eg to start, turn the key, wait for the green light then press the green button.  To stop it push the red button.  The main program may contain other programs to do other administrative tasks.  For example, there may be a program to exchange data with the Operator Interface / HMI.  There might be programs that connect to databases or IOT programs logging information etc.  The machine level program as far as this document is concerned is dedicated to running the machine.  The machine level block accepts commands, sequences the Equipment Modules, and reacts to alarms/errors of the Equipment modules. </p>"},{"location":"DesignGuide/index.html#module-separation","title":"Module Separation","text":"<p>As stated, the programmer at each level is concerned with their level and only their level only, that is why the interfaces exist, they give a clear definition of where responsibility ends.  A module communicates only with one layer above and only with one layer below.  For example, the Equipment Module, the equipment module receives commands from the Machine Layer via it's inputs/method calls.  The Equipment Module then communicates to the Components which operate their hardware.  The Machine has no business communicating directly with a Component. This abstraction allows Components to be replaceable without requiring the machine to be re-written. Eg Replacing a Servo drive with a DC Motor in the Unwind. The Equipment Module simply says \u201cComponent\u201d run at this speed. The machine is none the wiser.     </p>"},{"location":"DesignGuide/index.html#error-responseerror-propagation","title":"Error response/Error Propagation","text":"<p>Part of the separation of modules is the error handling. Compartmentalizing functions also means the errors can be compartmentalized.  Errors have different meanings at different levels, each level gives the error context.  \"Axis 5 lag distance fault\" is meaningless at the Machine Level.  The Machine wants to know, \u201cWas this error severe enough to stop the entire machine?\u201d and the operator wants to know \u201chow do I get back in operation\u201d.  When a Component has an error, it reports its specific error.  The Equipment Module sees the Component error and determines what it means for the Equipment Module and reports an Equipment Module Error.  The Machine sees the Equipment Module error and finally determines if the entire machine must be stopped or not.  Axis 5? Lag distance fault?  The back gauge is not in position.  Do not allow machining of the part to start, the part isn\u2019t in the right place.  </p> <p> </p> Error Propagation and Reaction <p>The complete sequence of error reporting and reaction is as follows:</p> <ol> <li>Components reports error to the Equipment Module</li> <li>Equipment Module determines the appropriate reaction for its other Components</li> <li>Equipment Module issued commands to the Components</li> <li>Equipment Module Reports the Equipment Modules Error to the Machine.</li> <li>Machine determines appropriate reaction for the other Equipment Modules</li> <li>Machine issues commands to all Equipment Modules</li> <li>Equipment Modules process the commands</li> <li>Equipment Modules issue commands to the Components</li> </ol> <p>For example, a Machine has an Equipment Module that is an X-Y table.  Within the equipment module are two Axis Components, X and Y.  The Component for the X-axis reports a lag distance fault.  The Equipment Module sees this lag fault on the X-axis, determines that the Y-axis should be stopped immediately; it stops the Y-Axis and reports to the machine that the X-Y table is no longer operational due to a problem with the X-Axis.  The machine sees that the X-Y Table is no longer functional and, in this case, determines that without the X-Y table nothing should operate.  The Machine commands all Equipment Modules to stop and cannot be re-started until the X-Y Table Error is fixed, and the operator is informed the entire systems stopped due to the X-Y Table. </p>"},{"location":"DesignGuide/index.html#error-logging-vs-alarm-display","title":"Error Logging vs Alarm Display","text":"<p>Everything should be logged, but not everything should be displayed.  Each Module must log all its errors and timestamp it.  Logs are for Service and the Development Engineers; Alarms are how the machine tells the operator what needs to be done to run. Alarms must be clear and relevant, with the most urgent displayed first.  The operator will generally not be looking at the screen when the alarm was raised.  When the operator arrives at the machine it must be readily apparent where the problem lies and what to do.  Like everything, there are several ways to handle this.  This is an important topic some of the first things written in the Components will be the error/fault reporting.</p> <p>Following the error propagation sequence a root cause error at a component will generate 3 messages, one at the component, one at the equipment module, and one at the machine level. There are some options for handling this.  </p> <ol> <li> <p>Each module reports its own error and via ID numbering schemes it can be determined all 3 errors are associated and either the HMI or the PLC ties makes the association to tie them together.</p> </li> <li> <p>The lowest level module generating the error reports it, higher levels add information to the same alarm. </p> </li> <li> <p>Only the machine layer reports the errors.  The Machine layer knows \u201cis told\u201d via either configuration or programming of every possible message from the equipment modules and Components and manages them. This is often the \u201cold school\u201d way of doing things, every module/device provides a list of all possible errors and the machine and global error numbers are assigned. </p> </li> <li> <p>Component faults are captured by the equipment module and only the equipment module provides the alarm up to the machine.    </p> </li> </ol> <p>A traditional alarm handler looks through all the devices\u2019 errors and determines what to report.  With the core idea being modularity and interchangeability of components, this ends up being a duplication of effort.  Every module within the machine has already had to recognize and react to the alarm, now a full second set of logic must look thorough all the faults on all modules and determine what messages to display.  It can generally be surmised that the Component faults are the root cause but that may not be the case, if a safety system is tripped many components will fault and it can all happen in a single PLC cycle. Did the safety drop the power or did the power drop cause the safety system to trip?  Properly timestamping and raising the fault/error/alarm directly makes sequencing easy. </p> <p>Another option is alarms \u201cdrill down\u201d when looking at the machine layer, equipment module errors are displayed, when looking at an equipment module, errors from the local components are displayed.  X-Y table has an error, drill down to the X-Y table and the X axis jammed.  To see the X axis jammed, the operator will have to look at the X-Y table equipment module.  As Operators become more familiar with the machine, they will learn that the X axis lag distance fault means a jam they need to go fix.  The operator doesn\u2019t want to have to click on everything to see the root cause.  </p> <p>For modularity, it is very easy to have every device write to the list in the order things happen.  The problem is if there is text associated with each alarm.  This text must be translated; this means list of text must be exported/imported.  If each device has its own list, then a bunch of different lists need to be sent for translation.   This is not a significant problem, text for the messages can be stored in files or databases, but it must be managed.  If the text is handled by the HMI, then it will need to be provided with these files or databases so that it can perform the text lookup. </p>"},{"location":"DesignGuide/index.html#errorfault-categorizationclassification","title":"Error/Fault Categorization/Classification","text":"<p>Regardless of the alarm handling methodology employed for modules are going to have unique faults and need to be readily identifiable and probably lots of them. Developing an error reaction to every single fault is not practical.  Fault Categorization/Levels can help with this.  To react to a fault, the severity of the fault is important, not the specific error message. Is the fault bad enough that this module must stop?  Do other components also need to stop?  Setting up Levels for faults greatly reduces the programming/implementation effort and ensures consistency between Modules. Note levels of the faults can also indicate how the fault should be reacted to.  EG Critical/Abort the Machine or Equipment Module must be stopped immediately. Cycle Stop faults allow the equipment module to \"finish\" but they cannot be restarted.  There seems to be no definitive standard on alarm categories and classes.  ISA 18.2 does cover alarms but for plant alarms with things like Category 1 is severe, risk of loss of entire plant or environmental contamination outside the facility a little beyond our scope.  Some systems implement 4 categories some recommend more.  </p> <p>The TwinCAT Event Logger logs 5 \"PC event types\" natively.   </p> <ol> <li>Verbose </li> <li>Info </li> <li>Warning</li> <li>Error</li> <li>Critical </li> </ol> <p>These categories could be used to determine the severity of the alarm or to differentiate between debugging/logging and errors and what the reaction should be.  Eg Critical means the module has aborted and cannot receive new commands.  </p> <p>Other systems use error categories that determine the course of action the machine should take. </p> <ol> <li>Critical/Immediate Stop/Abort the Module/Component cannot/does not function  </li> <li>Severe/Cycle Stop The Module should be stopped and not commanded again. </li> <li>Idle / machine functions hold preventing a next part to be started </li> <li>Hold/local condition.  The machine can function but is low on a material </li> <li>Suspend/External.  This Module/Machine is stopped waiting on other Modules/Machines from running.  </li> <li>Warning  Machine/Module operates but the user requires information about a condition that could lead to a higher category fault </li> <li>Info </li> </ol> <p>A traditional variation on the theme is to allocate X bits to each module for each level where each bit represents an error.  This makes some things easy, no bits set, no error but this only really works well up to 64 bits after that OR'ing multiple LWORDS gets complicated.  32 bits can be used to either represent 32 errors, or used as a UDINT, which can now represent 4.2 billion errors and via module ID's a scheme of errors can be configured to cover nearly every possibility.  One advantage of this methodology is that all errors can be displayed simultaneously any error that is active is reported.  If Error ID\u2019s are used, one possibility is the module only reports the first or highest priority error often this is the only one that matters.  A second option is the module could log to each error to an error handle as they appear even multiple errors in the same cycle.   The third option is that the Module contains a list of sufficient length to report all currently active errors. </p> <p>Regardless of the scheme is chosen, be consistent and clear the modules need to log their errors and keep track of their active errors so the alarm handler can report/acknowledge the alarms accordingly. </p> <p>Having levels/categories can make the equipment module and machine level programming significantly easier.  If category/level 1 faults mean the module will no longer work, then it's simple at the machine layer to say, for any level 1 error from this equipment module stop the entire machine.  Level one error from this module?  Finish the cycle and don\u2019t start a new one.    </p>"},{"location":"DesignGuide/index.html#layout","title":"Layout","text":"<p>Once it is known what everything must do, how to implement it?</p> <p> </p> Module Hierarchy <p>Items at each level must talk to one level up and one level down.  All blocks, regardless of what they are communicate via an interface.</p>"},{"location":"DesignGuide/index.html#interfaces","title":"Interfaces","text":"<p>As indicated before an interface is simply a defined way of two things interacting with each other.  For code, that means how a piece of code A talks to with another piece of code B.  A well-defined interface allows B to be replaced by C without requiring any changes to A.  Back to the earlier car example, the diesel car can be replaced by electric car and the Intern is still able to go pick up lunch.  Telling the Intern to take the skid steer  and go get lunch is a recipe for disaster.  This vehicle\u2019s interface is drastically different and requires specialized training.</p> <p>How do interfaces apply to PLC Code?  All functions, function blocks, and add-on instructions have an interface. The input, output, and in/out variables define the interface.  In TwinCAT 3 function blocks also have the capability of implementing Methods and Properties.  Methods and Properties have been a staple of nearly major programming languages since the 1970\u2019s.  Methods are functions/subroutines for the Function Block called by the user.  Methods are things that the Function Block can \u201cdo\u201d.  Method names should always be verbs. Properties are characteristics of the block, i.e. what the block \u201cis\u201d or \u201chas\u201d and should always be nouns.  Back to the car example, methods would be Accelerate, Decelerate, Turn Left, and Turn Right.  Properties would be things like Color, VIN Number and Number of seats.  For the Bank Machine, Properties would be things like \u201cCashInBox\u201d, and methods would be \u201cCallBank\u201d and \u201cDispenseCash\u201d.   </p> <p>For blocks to be interchangeable, they must use the same interface.  When building an interface, it needs to be determined what functionality must be provided and what data will be available.  Which methods and properties each block must support, and which variables will be passed in and out.  This process is a discussion, the user of the block and the builder of the block together need to determine what the interface will be.  There will be changes as deficiencies are found.    </p> <p>Point to Point axis Components should be interchangeable.  The ability to swap a stepper for a servo or a DC motor without changing the equipment module code is highly desirable. The same for the ability to swap one servo drive type/manufacturer for another.  Different hardware will do things in different ways.  The reset sequence for a stepper motor is very different from the reset sequence for a fieldbus connected servo motor.  The Equipment Module that asks for a reset, does not care about \u201chow\u201d the reset is done, it just wants a reset done.  Having separate Components that are interchangeable but \u201cperform the same function\u201d allows lower cost machine variation.  Some customers may be willing to pay for high performance servo axis and some customers would prefer lower cost stepper motors. The easier it is to swap Components the lower the engineering cost for modifications.  For example, a simple Point to Point axis block could have the following interfaces: </p> <p>Option 1: Methods, Properties, Inputs, Outputs and Var_In_Out</p> Method Property Input Output InOut (cyclic) Reset Position (mm) Enable Error Axis  Reference Move(Pos,Vel) Position (inch) Error ID Stop Busy Ready <p>The interface defines the rules for the Axis block.  The \u201cuser\u201d of the block reads the interface and knows what an axis can do, the person who builds the Axis block reads the interface and knows what features/functions to provide. If all different versions of axis blocks use the same interface, then anyone who knows how to use one axis block knows how to use all axis blocks regardless of whether it is a Linear, Servo, Stepper or Hydraulic axis.  Same interface, same usage, directly exchangeable.</p> <p>It is up to the company/programming team to define rules for creating interfaces.  Should all inputs and outputs should be handled by Methods and Properties, or via Input and Output variables or both? It is just as easy to write <code>Axis1.Reset := TRUE;</code> as it is to say <code>Axis1.Reset();</code>  The same for outputs, <code>Axis1.Error</code> or <code>Axis1.GetError()</code>. Position could easily be an output, instead of a property.</p> <p>Here are 4 more options for the PointToPoint Axis Block interface.  Each has its own advantages and disadvantages.  Choosing a consistent interface layout will key.  Options 3 and 5 below have special advantage in that they can be declared as a type \u201cInterface\u201d which is described in the next section. </p> <p>Option 2: Inputs and Outputs Only</p> Input Output Enable Position Inch Reset Position mm Move Error Move Position Error ID Move Velocity Busy Stop Ready <p>This is the traditional approach for function blocks</p> <p>Option 3: Methods and Properties Only</p> Method Property Reset Position Inch Move (Pos,Vel) Position mm Stop Error Enable Error ID Disable Busy Ready <p>Option 4: Inputs and Outputs with Command and Parameters</p> Input Output CMD Position Inch P1 Position mm P2 Error Abort Error ID Reset Busy Start Ready CMD Done <p>This Interface requires a documentation for what each CMD number is what the Parameters P1 and P2 represent for different commands.  For example, CMD = 1 could be a Move command  where P1 is position and P2 is Velocity.  CMD = 2 could be stop where P2 is the deceleration. </p> <p>Option 5: Methods and Properties with Commands and Parameters</p> Method Property Reset Position Inch CMD(P1,P2) Position mm Abort Error Error ID Busy Ready CMD Done <p>Just like Option 4, Option 5 would need documentation about what each command is and what the parameters do for each Command. </p>"},{"location":"DesignGuide/index.html#interface-data-type","title":"Interface Data Type","text":"<p>For TwinCAT 3 there is an interface data type. Interfaces defined by a data type are much more rigid.  When a defined data type interface is implemented, all Methods and Properties MUST be included.  The code will not compile if a block implementing an interface does not do it fully.  All blocks implementing an interface data type will be interchangeable the compiler forces this.  This significantly improves the reusability and consistency of the code. </p> <p>Variable Inputs, Variable Outputs and Var_In/Outs are not included in the Interface data type, and therefore the compiler does not force the programmer to use the same variable names.  External documentation is required if programmers are to use the same variable names.  Someone must document what the interfaces are to be (this can be done directly in the code) and the rules must then be enforced when documented interfaces are not being followed.  \u201cYou didn\u2019t follow the interface.\u201d  \u201cYou changed the name of the Execute variable to Go.\u201d  \u201cGo back, look at the documentation and fix it\u201d.  When an Interface Data type is used, the code simply will not compile if the names of the properties and methods do not match to the declared interface.  Again, there is no right/wrong choice here, what is important is that all interfaces are designed in a consistent way.  Implementing some blocks with data type defined interfaces and others via variables, reduces readability, reduces re-usability, increases confusion, which ultimately requires more time/money than having a consistent system.  Two formats may be appropriate, Blocks using inputs and outputs for the interfaces must follow a specific set of rules, as new blocks must be property and method only and follow another set of rules.  Programming convention documents are not big documents, 3-5 pages is generally plenty. </p> <p>A second huge advantage of using a Type Declared Interface is the ability to \u201ccode against the interface\u201d.  When \u201ccoding against an interface\u201d the programmer can declare an instance of the interface and write all code using that interface only.  This is extremely advantageous when Interfaces have been defined but no code has been built.  The Equipment Module programmer can write all the code for a component before the Component is even started.  The interface says it has a reset command and when it is complete it will be done or have an error.  Eventually a Component that implements the interface will be completed.  When it is ready to us it, simply assign the instance of the block to an instance of the block.  Now all commands to the interface are issued to the actual block.  </p> <p> </p> I_Axis Interface <p>With such an interface, there can several axis blocks built for handling different hardware provided all axis blocks implement this interface, any axis block can be replaced with any other axis block and the higher-level program requires no changes.  Want to change a Stepper to a Servo?  Change one assignment statement or add an IF condition.</p>"},{"location":"DesignGuide/index.html#extending-components","title":"Extending Components","text":"<p>One \u201csimple\u201d option to handle the challenge of interchangeable components is to build one block that can do \u201ceverything\u201d.  For the axis block example, a single block can be built that has various options.  The options would then indicate what hardware the block is to be connected to and what features it has.  It could have options for steppers, options for different servos and options for different functions. </p> <p>Great everything is in one block that can do \u201ceverything\u201d.  The problem is this block is never finished.  It is continually being updated and its interface is continually changing and there\u2019s so many options no one understands it.  For Example, A new very low-cost version of stepper motor was sold as an option for an existing machine.  It requires a digital output to enable it, and a digital output to reset it.  \u201cCheap Digital Stepper\u201d option is now added to the block, the block is given 2 more output variables, and the \u201cAxis Type\u201d which is likely an enumeration is extended for the new Cheap Digital Stepper type.  This block will require a lot of documentation.  When an instance of this block is created, it has every variable of every possible axis type included.  This causes confusion.  The same for if functionality is to be added.  \u201cWhy are these inputs and outputs not linked, oh those are only there in the case Axis X was a cheap stepper motor we used one time 6 years ago\u201d.   When a new type of Cam Table is developed, this functionality must be added into the \u201cdo everything\u201d axis block.  Now all blocks even ones that do not use the new cam table function will have to contain large cam tables.  If no one is taking care of ensuring this block is in a library there will end up being several partial complete versions of the block.  One version might allow stepper control but not the new cam table.  One might allow for a new cam table but not for a servo on fieldbus X.  </p> <p>The result is no one uses the \u201cdoes everything\u201d block because it\u2019s too complicated. </p>"},{"location":"DesignGuide/index.html#start-small-and-extend-to-add-features","title":"Start Small and Extend to Add Features","text":"<p>Many blocks start with very high goals.  For this project a new Servo block will be built, it will be able to do point to point motion, flying shear functionality, and handle multiple cam table switching.  Every Axis in every project will use this block and all axis will have all possibilities. </p> <p>In reality, maybe 2 of the axis in a project will need Cam Table switching.  Someone is going to take a significant amount of time building this block.  Most axis will likely only need basic point to point motion, but this all this functionality needs to be programmed, tested, and debugged before anyone can use it. </p> <p>A better solution: Build a basic block for point-to-point motion.  This block has one function, point to point.  This block is great for any Equipment Module that needs point to point motion and doesn\u2019t require any information about a master axis.  This block is quick to build, test and debug and covers the basics, enable the axis reset the axis and move point to point, simple to build, simple to use. </p> <p>Axis that requires synchronization will also need point to point motion.  The point-to-point block can be extended.  The extended block contains everything the original has, it has an axis reference and point to point motion, components that have already been tested and work.  For synchronization it needs the master axis information.  When the block is extended a master axis reference is added, and basic camming/gearing can be added.  If an error is found is ever found in the point-to-point block, fixing it in the point-to-point block automatically fixes it in the extended Synchronization block.  If a \u201cShortest way\u201d option is added to the point-to-point block, it automatically appears in the Synchronization block.  The programmer of the extended block can focus on the extension knowing the rest already works.   </p> <p>This idea of small blocks and extension, results in the most code re-use.  The base axis from one project is now \u201cin demand\u201d for the next project because the block has been significantly tested and does not include things that are not necessary.  For point to point, it is perfect.  When the complexity is necessary, the Extended block is used.  However, when the complexity is not required the simple base block can be used without the \u201cclutter\u201d of unused functionality.  </p> <p>If the basic block was chosen, and later it\u2019s determined the extended block is necessary, no problem, switch the basic block for the extended version.  The Extended block still contains the basic block and all the existing code that used the basic block still works for the extended version. </p> <p>This is inheritance and this is probably the single most powerful feature available in TwinCAT 3.   Extending blocks is always available, even if Interface Data types are not used.  Blocks in libraries can also be extended.   The extended block cannot break the base block, it can only add to it and only the new functionality requires testing and debugging.  In the event the new block needs to change how a basic function works, the methods can be extended or overridden.  If the new block has new hardware and the reset must be different?  No problem, override the base block\u2019s Reset method to include the code for handling the new hardware.  </p>"},{"location":"DesignGuide/index.html#define-the-functionality","title":"Define the Functionality","text":"<p>Now it is known which Equipment Modules and Components will exist and what the interfaces will look like, time to start writing code. </p> <p>Not so fast! Before writing a single line of code, either on paper or in a spreadsheet determine what functions the Machine each Equipment Module must be able to do in each mode of operation and what happens in the case of an error level of error of each Module.   Modules always has more than one mode of operation, it is going to require a manual mode for jogging axis after a jam, it may have a clearing mode to clear out partially completed products, and it will very likely have a dry cycle mode for operating without product.  Everyone (management) is always concerned about Automatic/Producing mode; this is theoretically, where the machine makes money.  This mode is important, but it is generally \"easy\" because everything is running.  All the other modes, functions, and features take time to build, and they need to be planned in at start.  Adding core functions later without planning has the most risk of \u201cbreaking\u201d components already completed. Create a Document/Spreadsheet that does the following: </p> <ol> <li>Defines all modes of operation of the machine and each equipment module.  It is common that different equipment modules will be in different operation modes at different times.  Putting a single equipment module into manual while the machine is in production is fairly standard. </li> <li>Determines what each Module must do in each mode </li> <li>Contains a list of what Errors can occur each Module (this list will be added to as construction progresses) </li> </ol> <p>Creating a table for each Equipment and Component and laying out the functionality in each mode does two things. </p> <ol> <li>It provides a complete scope of work of how many functions really must be implemented </li> <li>It clarifies the operation of the entire machine.</li> </ol> <p>If the machine is built without a full plan, after the machine produces the first product comes the statement, \"Great that works. Now during product change over before we load a new material, these two axis\u2019 have to decouple and this one has to stop in order to release tension here.\"  Whoa, wait, what?!?  If I had known that I would have done all this slightly differently to accommodate that. Patching in unplanned functionality later typically causes the most unintended consequences.  After patching in the new function, the next problem report is, \"Uh, somehow while running the machine the operator started the load process, that decoupled the axes, released the tension, the film wrapped around the dancer and bent the arm, we need a new part machine will be down for a week\".  </p> <p>Laying out the functionality for each Module takes time, it may take a couple of days or a week or more depending on the complexity of the machine.  However, when completed the project timeline will be more accurate, it will save days/weeks of effort at the end of the project when time is most precious.  The phrase \"If we knew that, we would have done this instead\" is a huge problem before run off.  Now comes the debate, re-do a major component, which will prevent the machine from running until it is completed, or try to somehow shoehorn in the extra functionality. Usually, the shoehorn method is employed until it's finally determined that the block must be re-built, and even more time is lost. </p> <p>Producing mode is important but the customer only complains when the machine is not producing.  The end user paid for production mode, every minute the machine is not in production mode is costing money, getting the machine back into production quickly is where the money is.  </p> <p>There will be a sequence to start up the machine and there will be different functionality in different modes of operation.  Commissioning, Maintenance, unsticking things after a jam, there's a lot of functionality needed that is not \"automatic production\".  No problem, build a Mode handling and a state machine to help ensure functions from Manual mode are not accidentally triggered in Automatic mode.  There are now two options, come up with your own Mode and State sequencing system, or follow a standard.  For those who build/have their own Mode/State handling system, that is perfectly acceptable.  Doing it your own way comes with the task of building/debugging your system, documenting your mode/state handling system, and teaching your system to other programmers, service people, and the end user.  Having the ability to say this machine conforms to ISA TR88.00.02 makes things a lot simpler. The TR88.00.02 Implementation guide from OMAC describes the implementation of TR88 very well. </p>"},{"location":"SPT_Base_Types/index.html","title":"Class Diagram","text":"<pre><code>classDiagram\n    I_BaseFB &lt;|-- I_CyclicFB\n    FB_BaseFB ..|&gt; I_BaseFB    \n    FB_CyclicFB --|&gt; FB_BaseFB\n    FB_CyclicFB ..|&gt; I_CyclicFB\n\n    class I_BaseFB{\n        &lt;&lt;Interface&gt;&gt;\n        +BOOL Busy\n        +BOOL Error\n        +UDINT ErrorID\n    }\n\n    class I_CyclicFB{\n        &lt;&lt;Interface&gt;&gt;\n        +BOOL InitComplete\n        +CyclicLogic()\n    }\n\n    class FB_BaseFB{\n        &lt;&lt;Abstract&gt;&gt;\n        Trace()\n        TraceWithJson()\n        Marker()\n    }\n\n    class FB_CyclicFB{\n        &lt;&lt;Abstract&gt;&gt;\n    }\n\n</code></pre>"},{"location":"SPT_Base_Types/index.html#design-notes","title":"Design Notes","text":"<p>Throughout the framework libraries a common pattern is used for initialization routines and how they are called.  </p> <p>Most function blocks will implement <code>I_CyclicFB</code> by way of inheriting <code>FB_CyclicFB</code>.  The entry point for these function blocks is <code>CyclicLogic()</code>.  <code>FB_CyclicFB</code> already contains a local variable backing the <code>InitComplete</code> property: <code>_InitComplete : BOOL</code>.  We can utilize this in our function blocks and assure all necessary initialization steps have been carried out before executing any further code.  This can be useful, for example, to make sure pointers are initialized before referencing them.  Another example may be waiting for another function block to set a property on our function block--useful when implementing the Observer pattern.</p> <pre><code>IF NOT _InitComplete THEN  \n    _InitComplete := Initialize();\n    RETURN;\nEND_IF\n\n...code to run once initialization is complete\n</code></pre>"},{"location":"SPT_Base_Types/changelog.html","title":"Changelog","text":""},{"location":"SPT_Base_Types/changelog.html#unreleased","title":"[Unreleased]","text":""},{"location":"SPT_Base_Types/changelog.html#310-2023-04-14","title":"[3.1.0] - 2023-04-14","text":""},{"location":"SPT_Base_Types/changelog.html#added","title":"Added","text":"<ul> <li>Added FB_ControlSource</li> <li>Added contents of SPT_PackML_Base library as part of consolidation effort</li> <li>Added contents of SPT_ComponentBase library as part of consolidation effort</li> <li>Added contents of SPT_Tracing library as part of consolidation effort</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#302-2023-02-15","title":"[3.0.2] - 2023-02-15","text":""},{"location":"SPT_Base_Types/changelog.html#fixed","title":"Fixed","text":"<ul> <li>Updated FB_BaseFB.TraceWithJson() to correctly call AddEntryWithJson()</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#301-2022-10-05","title":"[3.0.1] - 2022-10-05","text":""},{"location":"SPT_Base_Types/changelog.html#added_1","title":"Added","text":"<ul> <li>Added Trace() method to FB_BaseFB</li> <li>Added Marker() method to FB_BaseFB</li> <li>Added TraceWithJson() method to FB_BaseFB</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#300-2022-10-05","title":"[3.0.0] - 2022-10-05","text":""},{"location":"SPT_Base_Types/changelog.html#added_2","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_Base_Types/duts.html","title":"Data Types","text":""},{"location":"SPT_Base_Types/duts.html#enums","title":"ENUMs","text":""},{"location":"SPT_Base_Types/duts.html#e_alarmresponse","title":"E_AlarmResponse","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_AlarmResponse : (\n        Abort_ImmediateError,\n        Abort_Immediate,\n        Stop_Immediate,\n        Stop_Controlled,\n        Hold_Immediate,\n        Hold_Controlled,\n        Suspend_Immediate,\n        Suspend_Controlled,\n        NoResponse\n    );\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#e_pmlunitmode","title":"E_PMLUnitMode","text":"<pre><code>TYPE E_PMLUnitMode : (\n        ePMLUnitMode_Invalid     := 0,\n        ePMLUnitMode_Production  := 1,\n        ePMLUnitMode_Maintenance := 2,\n        ePMLUnitMode_Manual      := 3,\n        ePMLUnitMode_UserMode1   := 4,\n        ePMLUnitMode_UserMode2   := 5,\n        ePMLUnitMode_UserMode3   := 6,\n        ePMLUnitMode_UserMode4   := 7,\n        ePMLUnitMode_UserMode5   := 8,\n        ePMLUnitMode_UserMode6   := 9,\n        ePMLUnitMode_UserMode7   := 10,\n        ePMLUnitMode_UserMode8   := 11,\n        ePMLUnitMode_UserMode9   := 12,\n        ePMLUnitMode_UserMode10  := 13,\n        ePMLUnitMode_UserMode11  := 14,\n        ePMLUnitMode_UserMode12  := 15,\n        ePMLUnitMode_UserMode13  := 16,\n        ePMLUnitMode_UserMode14  := 17,\n        ePMLUnitMode_UserMode15  := 18,\n        ePMLUnitMode_UserMode16  := 19,\n        ePMLUnitMode_UserMode17  := 20,\n        ePMLUnitMode_UserMode18  := 21,\n        ePMLUnitMode_UserMode19  := 22,\n        ePMLUnitMode_UserMode20  := 23,\n        ePMLUnitMode_UserMode21  := 24,\n        ePMLUnitMode_UserMode22  := 25,\n        ePMLUnitMode_UserMode23  := 26,\n        ePMLUnitMode_UserMode24  := 27,\n        ePMLUnitMode_UserMode25  := 28,\n        ePMLUnitMode_UserMode26  := 29,\n        ePMLUnitMode_UserMode27  := 30,\n        ePMLUnitMode_UserMode28  := 31\n    ) DINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#structs","title":"STRUCTs","text":""},{"location":"SPT_Base_Types/duts.html#st_componentbase_hmi","title":"ST_ComponentBase_HMI","text":"<pre><code>TYPE ST_ComponentBase_HMI :\n    STRUCT\n        Config  : ST_ComponentBase_Config;\n        Command : ST_ComponentBase_Command;\n        Status  : ST_ComponentBase_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_componentbase_config","title":"ST_ComponentBase_Config","text":"<pre><code>TYPE ST_ComponentBase_Config :\n    STRUCT\n        Name : STRING;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_componentbase_command","title":"ST_ComponentBase_Command","text":"<pre><code>TYPE ST_ComponentBase_Command :\n    STRUCT\n        SimulatedOperation : BOOL;\n        StandardOperation  : BOOL;\n        Reset              : BOOL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_componentbase_status","title":"ST_ComponentBase_Status","text":"<pre><code>TYPE ST_ComponentBase_Status :\n    STRUCT\n        InSimulation        : BOOL;\n        Busy                : BOOL;\n        Error               : BOOL;\n        ErrorID             : UDINT;\n        HMIControlAvailable : BOOL; //Set TRUE *FROM PLC* when HMI requests can be processed\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_packmlbasemodule_hmi","title":"ST_PackMLBaseModule_HMI","text":"<pre><code>TYPE ST_PackMLBaseModule_HMI :\n    STRUCT\n        Config  : ST_PackMLBaseModule_Config;\n        Command : ST_PackMLBaseModule_Command;\n        Status  : ST_PackMLBaseModule_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_packmlbasemodule_config","title":"ST_PackMLBaseModule_Config","text":"<pre><code>TYPE ST_PackMLBaseModule_Config :\n    STRUCT\n        Name            : STRING;       //Human-readable module name for user-side messaging\n        LogStateChanges : BOOL := TRUE; //Toggle to permit or suppress state change logging (Should be tied to HMI setting to optionally reduce event logger clutter)\n        LogModeChanges  : BOOL := TRUE; //Toggle to permit or suppress state change logging (Should be tied to HMI setting to optionally reduce event logger clutter)\n        ModeNames       : ARRAY[0..31] OF STRING;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_packmlbasemodule_command","title":"ST_PackMLBaseModule_Command","text":"<pre><code>TYPE ST_PackMLBaseModule_Command :\n    STRUCT\n        Mode               : E_PMLUnitMode              := Parameters_PackML_Base.UNIT_MODE_DEFAULT;\n        State              : Tc3_PackML_V2.E_PMLCommand := Parameters_PackML_Base.UNIT_STATE_DEFAULT;\n        ActivateStateLog   : BOOL; //HMI requests to enable the module\n        DeactivateStateLog : BOOL; //HMI requests to disable the module\n        ActivateModeLog    : BOOL; //HMI requests to enable the module\n        DeactivatModeLog   : BOOL; //HMI requests to disable the module\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_packmlbasemodule_status","title":"ST_PackMLBaseModule_Status","text":"<pre><code>TYPE ST_PackMLBaseModule_Status :\n    STRUCT\n        Busy                : BOOL;\n        Error               : BOOL;\n        ErrorID             : UDINT;\n        Mode                : E_PMLUnitMode;\n        State               : Tc3_PackML_V2.E_PMLState;\n        HMIControlAvailable : BOOL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_packml_control","title":"ST_PackML_Control","text":"<pre><code>TYPE ST_PackML_Control :\n    STRUCT\n        CurrentMode      : E_PMLUnitMode;\n        ModeCommand      : E_PMLUnitMode;\n        CurrentState     : E_PMLState;\n        StateCommand     : E_PMLCommand;\n        ModeNames        : ARRAY[0..31] OF STRING;\n        ModeCommandLast  : E_PMLUnitMode;\n        StateCommandLast : E_PMLCommand;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_packml_control_simplified","title":"ST_PackML_Control_Simplified","text":"<pre><code>TYPE ST_PackML_Control_Simplified :\n    STRUCT\n        ResetPermissive     : BOOL;\n        StartPermissive     : BOOL;\n        StopPermissive      : BOOL;\n        ResetPressed AT %I* : BOOL;\n        StartPressed AT %I* : BOOL;\n        StopPressed  AT %I* : BOOL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_Base_Types/functionblocks.html#fb_basefb","title":"FB_BaseFB","text":"<p>(abstract, implements <code>I_BaseFB</code>)</p> <p>Contains property backers for all <code>I_BaseFB</code> properties.  This is the most basic building block of all framework function blocks.  Can be directly inherited-if so, entry point is up to the developer.</p> <p>Info</p> <p>See I_BaseFB for more information.</p>"},{"location":"SPT_Base_Types/functionblocks.html#methods","title":"Methods","text":"Method Return Type Access Description Marker null PUBLIC Adds a message to the global trace log and sets its <code>Flags</code> to 1 Trace null PUBLIC Adds a message to the global trace log TraceWithJson null PUBLIC Adds a message to the global trace log along with additional JSON object"},{"location":"SPT_Base_Types/functionblocks.html#trace","title":"Trace()","text":"<pre><code>METHOD PUBLIC Trace\nVAR_INPUT\n    Message : T_MaxString;\nEND_VAR\n</code></pre> <p><code>Message</code> should be the textual description of the debug message.</p>"},{"location":"SPT_Base_Types/functionblocks.html#tracewithjson","title":"TraceWithJson()","text":"<pre><code>METHOD PUBLIC TraceWithJson\nVAR_INPUT\n    Message : T_MaxString;\n    Json    : T_MaxString;\nEND_VAR\n</code></pre> <p><code>Message</code> should be the textual description of the debug message.  <code>Json</code> should be a properly formatted JSON object.</p>"},{"location":"SPT_Base_Types/functionblocks.html#fb_componentbase","title":"FB_ComponentBase","text":"<p>(abstract, extends <code>FB_CyclicFB</code>, implements <code>I_ComponentBase</code>)</p> <p>Contains property backers for all <code>I_ComponentBase</code> properties as well as basic housekeeping code for all component-level function blocks.</p> <p>All <code>PROTECTED</code> methods can and usually should be overridden for component-specific functionality (HMI commands, event handling, etc.) and then called using <code>SUPER^.Method()</code>.</p> <p>Info</p> <p>See I_ComponentBase and FB_CyclicFB for more information.</p>"},{"location":"SPT_Base_Types/functionblocks.html#createevents","title":"CreateEvents()","text":"<p><code>METHOD PROTECTED CreateEvents</code></p> <p>If a component has its own specific events defined, override this method to initialize them and then call <code>SUPER^.CreateEvents()</code> to initialize the base component events.</p>"},{"location":"SPT_Base_Types/functionblocks.html#hmicommunication","title":"HMICommunication()","text":"<p><code>METHOD PROTECTED HMICommunication</code></p> <p>Override and <code>SUPER^</code> call this method to implement component-specific HMI commands, status, configuration items.  The base method uses a predefined local <code>HMICommandActive_Descendant</code> as an interlock to ensure only one command is fired at a time, whether it's a base command or a component-specific command.  The base method also provides <code>HMICommandActive_Base</code> for you to use in your custom method extensions.</p> <p>Info</p> <p>See ST_ComponentBase_HMI for more information.</p> <p>Example</p> <pre><code>SUPER^.HMICommunication();\nHMICommand_MyComponent_RT(CLK := (ComponentBase_HMI.Status.HMIControlAvailable AND NOT HMICommandActive_Base) AND (MyComponent_HMI.Command.MyCommand XOR MyComponent_HMI.Command.MyOtherCommand));\n\n//Signal to FB_ComponentBase that a command is active\nHMICommandActive_Descendant := ComponentBase_HMI.Status.HMIControlAvailable AND (MyComponent_HMI.Command.MyCommand OR MyComponent_HMI.Command.MyOtherCommand OR MyComponent_HMI.Command.Jog);\n\n//Process Momentary HMI requests\nIF HMICommand_MyComponent_RT.Q THEN\n    IF MyComponent_HMI.Command.MyCommand THEN\n        MyCommand();\n    ELSIF MyComponent_HMI.Command.MyOtherCommand THEN\n        MyOtherCommand();\n    END_IF\nEND_IF\n\n//Handle non-momentary commands such as jogging\nIF ComponentBase_HMI.Status.HMIControlAvailable AND NOT HMICommand_MyComponent_RT.Q THEN\n    IF MyComponent_HMI.Command.Jog THEN\n        MyComponent.Jog();\n    END_IF\nEND_IF\n\n//Update HMI status info\nMyComponent_HMI.Status.Red   := Red;\nMyComponent_HMI.Status.Green := Green;\nMyComponent_HMI.Status.Blue  := Blue;\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#initialize","title":"Initialize()","text":"<p><code>METHOD PROTECTED Initialize</code></p> <p>In cases where a custom component contains one or many other components within, override <code>Initialize()</code> and interlock the <code>SUPER^.Initalize()</code> call with the <code>InitComplete</code> property of your subcomponent(s).  <code>CyclicLogic()</code> should also be overridden and the calls to subcomponents' <code>CyclicLogic()</code> placed within.  Through a long and complicated call chain, this pattern will ensure subcomponent(s) have initialized completely before your custom component reports <code>InitComplete = TRUE</code>.</p> <p>Example</p> <pre><code>METHOD PROTECTED FINAL Initialize : BOOL;\n\nIF NOT (MySubcomponent1.InitComplete AND MySubcomponent2.InitComplete) THEN\n    RETURN;\nEND_IF\n\nIF SUPER^.Initialize() THEN\n    Initialize := TRUE;\nEND_IF\n</code></pre> <pre><code>METHOD PUBLIC FINAL CyclicLogic\n\nMySubcomponent1.CyclicLogic();\nMySubcomponent2.CyclicLogic();\n\n//My custom component's code/state machine here\n\nSUPER^.CyclicLogic();\n\n_Busy  := MainState &lt;&gt; Idle AND MainState &lt;&gt; Error;\n_Error := MainState = Error AND MainState &lt;&gt; Reset;\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#monitoring","title":"Monitoring()","text":"<p><code>METHOD PROTECTED Monitoring</code></p> <p>Override this method to add event handling to your custom component.</p> <p>Example</p> <pre><code>METHOD PROTECTED Monitoring\n\nSUPER^.Monitoring();\n\n//ErrorID 1 - MC_MoveVelocity\nIF BasicAxis.MC_MoveVelocity.Error AND NOT BasicAxisAlarms[E_BasicAxis.MoveVelocityError].bRaised THEN\n    RaiseAlarmWithStrings(Alarm := BasicAxisAlarms[E_BasicAxis.MoveVelocityError], UDINT_TO_STRING(BasicAxis.ErrorID), '');\nELSIF NOT BasicAxis.MC_MoveVelocity.Error AND BasicAxisAlarms[E_BasicAxis.MoveVelocityError].bRaised THEN\n    BasicAxisAlarms[E_BasicAxis.MoveVelocityError].Clear(0, 0);\nEND_IF\n\n//ErrorID 2 - MC_MoveRelative\nIF BasicAxis.MC_MoveRelative.Error AND NOT BasicAxisAlarms[E_BasicAxis.MoveRelativeError].bRaised THEN\n    RaiseAlarmWithStrings(Alarm := BasicAxisAlarms[E_BasicAxis.MoveRelativeError], UDINT_TO_STRING(BasicAxis.MC_MoveRelative.ErrorID), '');\nELSIF NOT BasicAxis.MC_MoveRelative.Error AND BasicAxisAlarms[E_BasicAxis.MoveRelativeError].bRaised THEN\n    BasicAxisAlarms[E_BasicAxis.MoveRelativeError].Clear(0, 0);\nEND_IF\n\n_CurrentAlarmSeverity := F_GetMaxSeverityRaised(Alarms := BasicAxisAlarms, CurrentSeverity := CurrentAlarmSeverity);\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#raisealarm","title":"RaiseAlarm()","text":"<p><pre><code>METHOD PROTECTED RaiseAlarm\nVAR_IN_OUT\n    Alarm : FB_TcAlarm;\nEND_VAR\n</code></pre> Raises an alarm with no arguments</p>"},{"location":"SPT_Base_Types/functionblocks.html#raisealarmwithstrings","title":"RaiseAlarmWithStrings()","text":"<p><pre><code>METHOD PROTECTED RaiseAlarmWithStrings\nVAR_IN_OUT\n    Alarm : FB_TcAlarm;\nEND_VAR\n\nVAR_INPUT\n    String_1 : STRING;\n    String_2 : STRING;\nEND_VAR\n</code></pre> Raises an alarm with optional contextual information.  In actuality the event being raised takes 3 string arguments, but the component's <code>Name</code> is automatically passed as the first argument.</p>"},{"location":"SPT_Base_Types/functionblocks.html#raiseeventwithstrings","title":"RaiseEventWithStrings()","text":"<p><pre><code>METHOD PROTECTED RaiseEventWithStrings\nVAR_IN_OUT\n    Alarm : FB_TcAlarm;\nEND_VAR\n\nVAR_INPUT\n    String_1 : STRING;\n    String_2 : STRING;\nEND_VAR\n</code></pre> Raises an event with optional contextual information.  In actuality the event being raised takes 3 string arguments, but the component's <code>Name</code> is automatically passed as the first argument.  Events do not set the <code>Error</code> bit when they are raised.</p>"},{"location":"SPT_Base_Types/functionblocks.html#fb_controlsource","title":"FB_ControlSource","text":"<p>(abstract, extends <code>FB_CyclicFB</code>, implements <code>I_PackML_ExternalController</code>)</p> <p>A control source refers to any external device or system which needs to command a state/mode change or be notified of such a change by any I_PackML_Control.  These are usually submodules of otherwise descendants of FB_PackML_BaseModule.</p> <p>Examples of such a device are pushbutton groups, HMIs, or SCADA systems.</p> <p>Info</p> <p>See FB_CyclicFB and I_PackML_ExternalController for more information.</p> <p>Tip</p> <p>By extending <code>FB_ControlSource</code> and overriding <code>CyclicLogic()</code>, custom behavior can be designed to fit a particular need.</p>"},{"location":"SPT_Base_Types/functionblocks.html#properties","title":"Properties","text":"Property Type Access Description Registered BOOL R Flag indicating that the function block has been successfully registered with a submodule <p>CyclicLogic() Example</p> <pre><code>IF NOT _InitComplete THEN\n    _InitComplete := Initialize();\n    RETURN;\nEND_IF\n\n//Copy the module to the local mode and state\nMainPMLControl_Standard.CurrentMode  := ipModule.CurrentMode;\nMainPMLControl_Standard.CurrentState := ipModule.CurrentState;\nFOR i := 1 TO 5 DO\n    MainPMLControl_Standard.ModeNames[i] := F_UnitModeToString(TO_DINT(i));\nEND_FOR\n\n//Process requests\nR_HMICommand(CLK := (MainPMLControl_Simplified.ResetPressed XOR MainPMLControl_Simplified.StartPressed XOR MainPMLControl_Simplified.StopPressed) XOR\n                    (MainPMLControl_Standard.StateCommand &lt;&gt; E_PMLCommand.ePMLCommand_Undefined AND MainPMLControl_Standard.StateCommandLast &lt;&gt; MainPMLControl_Standard.StateCommand) XOR\n                    (MainPMLControl_Standard.ModeCommandLast &lt;&gt; MainPMLControl_Standard.ModeCommand));\n\nIF R_HMICommand.Q THEN\n    MainPMLControl_Standard.ModeCommandLast  := MainPMLControl_Standard.ModeCommand;\n    MainPMLControl_Standard.StateCommandLast := MainPMLControl_Standard.StateCommand;\n    IF MainPMLControl_Simplified.ResetPressed AND MainPMLControl_Simplified.ResetPermissive AND MainPMLControl_Standard.CurrentState = E_PMLState.ePMLState_Aborted THEN\n        ipModule.ChangeState(Tc3_PackML_V2.E_PMLCommand.ePMLCommand_Clear);\n    ELSIF MainPMLControl_Simplified.ResetPressed AND MainPMLControl_Simplified.ResetPermissive THEN\n        ipModule.ChangeState(Tc3_PackML_V2.E_PMLCommand.ePMLCommand_Reset);\n    ELSIF MainPMLControl_Simplified.StartPressed AND MainPMLControl_Simplified.StartPermissive THEN\n        IF MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Idle THEN\n            ipModule.ChangeState(Tc3_PackML_V2.E_PMLCommand.ePMLCommand_Start);\n        ELSIF MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Held THEN\n            ipModule.ChangeState(Tc3_PackML_V2.E_PMLCommand.ePMLCommand_Unhold);\n        END_IF\n    ELSIF MainPMLControl_Simplified.StopPressed AND MainPMLControl_Simplified.StopPermissive THEN\n        ipModule.ChangeState(Tc3_PackML_V2.E_PMLCommand.ePMLCommand_Stop);\n    ELSIF ipModule.StateCommand &lt;&gt; MainPMLControl_Standard.StateCommand THEN\n        ipModule.StateCommand := MainPMLControl_Standard.StateCommand;\n    ELSIF ipModule.ModeCommand &lt;&gt; MainPMLControl_Standard.ModeCommand THEN\n        ipModule.ModeCommand := MainPMLControl_Standard.ModeCommand;\n    END_IF\nEND_IF\n\n//Set the permissives for each button\nMainPMLControl_Simplified.StartPermissive :=\n    MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Idle OR MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Held;\n\nMainPMLControl_Simplified.StopPermissive :=\n    (MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V2.E_PMLState.ePMLState_Stopped AND MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V2.E_PMLState.ePMLState_Clearing AND\n    MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V2.E_PMLState.ePMLState_Aborted AND MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V2.E_PMLState.ePMLState_Aborting AND\n    MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V2.E_PMLState.ePMLState_Idle AND MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V2.E_PMLState.ePMLState_Undefined);\n\nMainPMLControl_Simplified.ResetPermissive :=\n    MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Complete OR MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Stopped OR\n    MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Aborted;\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#fb_cyclicfb","title":"FB_CyclicFB","text":"<p>(abstract, extends <code>FB_BaseFB</code>, implements <code>I_CyclicFB</code>)</p> <p>Contains property backers for all <code>I_CyclicFB</code> properties.  <code>CyclicLogic()</code> is introduced as the entry point. </p> <p>Info</p> <p>See I_BaseFB and FB_BaseFB for more information.</p> <p>Success</p> <p>No code should be written in the body of function blocks extending. <code>FB_CyclicFB</code>.  While nothing will break by doing so, it violates the design pattern of the framework.</p>"},{"location":"SPT_Base_Types/functionblocks.html#fb_packml_basemodule","title":"FB_PackML_BaseModule","text":"<p>(abstract, extends <code>FB_CyclicFB</code>, implements <code>I_PackML_BaseModule</code>, <code>I_PackML_Control</code>)</p>"},{"location":"SPT_Base_Types/functionblocks.html#methods_1","title":"Methods","text":""},{"location":"SPT_Base_Types/functionblocks.html#general","title":"General","text":"Method Return Type Access Description CreateEvents null PROTECTED Initializes base component events Initialize BOOL PROTECTED Basic initialization routine RegisterExternalController BOOL PUBLIC Takes an instance of <code>I_PackML_ExternalController</code> and adds it to an internal collection of external controllers.  External controllers are, for example, HMI or pushbutton aggregation function blocks. StateComplete null PROTECTED Signal to PackML state machine sequencer that this module can advance to the next state.  This is normally called automatically by the state sequencer."},{"location":"SPT_Base_Types/functionblocks.html#createevents_1","title":"CreateEvents()","text":"<p><code>METHOD PROTECTED CreateEvents</code></p> <p>If a module has its own specific events defined, override this method to initialize them and then call <code>SUPER^.CreateEvents()</code> to initialize the base component events.</p>"},{"location":"SPT_Base_Types/functionblocks.html#initialize_1","title":"Initialize()","text":"<p><code>METHOD PROTECTED Initialize</code></p> <p>The base <code>Initialize()</code> method handles some basic tasks like setting pointers, counting the number of submodules/components, and most importantly ensuring any children are completely initialized before itself returning <code>TRUE</code>.</p> <p>When creating an Equipment Module, override this method and implement your own routine.  Many times it makes sense to use a state machine to make sure things are called in order and only as required.  In fact, the base <code>Initialize()</code> does this using the predefined local <code>SequenceState</code> as the indexer.  A second predefined local <code>DescendantSequenceState</code> can be used for indexing a state machine in your overridden <code>Initialize()</code>.</p> <p>!!!! example <pre><code>METHOD PROTECTED FINAL Initialize : BOOL\nVAR\n    i : UDINT; //Generic iteration value\nEND_VAR\n\nCASE DescendantSequenceState OF\n    0:\n        // Define the interfaces to the different subunits (Must take place before SUPER^.initialize call)\n        FOR i := 1 TO SPT_PackMLBase.Parameters_PackML_Base.MAX_NO_OF_SUBMODULES DO\n            ipSubModules[i] := ipSubModules_Init[i];\n        END_FOR\n\n        FOR i := 1 TO SPT_PackMLBase.Parameters_PackML_Base.MAX_NO_OF_COMPONENTS DO\n            ipComponents[i] := ipComponents_Init[i];\n        END_FOR\n\n        LogModuleModeChanges    := FALSE;\n        LogModuleStateChanges   := FALSE;\n        DescendantSequenceState := DescendantSequenceState + 10;\n    10:\n        CustomModes(eMode                          := 4,\n                    sName                          := 'My Custom Mode',\n                    bDisableClearing               := FALSE,\n                    bDisableStarting               := FALSE,\n                    bDisableSuspended              := TRUE,\n                    bDisableStopping               := FALSE,\n                    bDisableAborting               := FALSE,\n                    bDisableHolding                := TRUE,\n                    bDisableHeld                   := TRUE,\n                    bDisableUnholding              := TRUE,\n                    bDisableSuspending             := TRUE,\n                    bDisableUnsuspending           := TRUE,\n                    bDisableResetting              := FALSE,\n                    bDisableIdle                   := FALSE,\n                    bDisableCompleting             := TRUE,\n                    bDisableComplete               := TRUE,\n                    bEnableUnitModeChangeStopped   := TRUE,\n                    bEnableUnitModeChangeIdle      := TRUE,\n                    bEnableUnitModeChangeSuspended := FALSE,\n                    bEnableUnitModeChangeExecute   := TRUE,\n                    bEnableUnitModeChangeAborted   := TRUE,\n                    bEnableUnitModeChangeHeld      := FALSE,\n                    bEnableUnitModeChangeComplete  := FALSE,\n                    bError                         =&gt;,\n                    nErrorId                       =&gt;);\n    20:\n        FOR i := 1 TO 4 DO\n            ModeNames[i] := F_UnitModeToString(UDINT_TO_DINT(i));\n        END_FOR\n\n        DescendantSequenceState := DescendantSequenceState + 10;\n    30:\n        IF SUPER^.Initialize() THEN\n            Initialize                 := TRUE;\n        END_IF\nEND_CASE\n</code></pre></p>"},{"location":"SPT_Base_Types/functionblocks.html#registerexternalcontroller","title":"RegisterExternalController()","text":"<p>Established a two-way link between an I_PackML_ExternalController and this submodule.  Allows for external control of mode/state as well as notification of such changes via callback.</p> <p>! info     See FB_ControlSource for more information.</p> <pre><code>METHOD FINAL RegisterExternalController : BOOL\nVAR_INPUT\n    Controller : I_PackML_ExternalController;\nEND_VAR\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#alarm-handling","title":"Alarm Handling","text":"Method Return Type Access Description AbortImmediate null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Aborted</code> AbortImmediateError null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Aborted</code> and an event will be raised HoldControlled null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Held</code> HoldImmediate null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Held</code> StopControlled null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Stopped</code> StopImmediate null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Stopped</code> SuspendControlled null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Suspended</code> SuspendImmediate null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Suspended</code> <p>Info</p> <p>The method which will be called on submodule or component fault depends on the severity of the event and the behavior defined by the subcomponent/component's <code>ParentResponseDefinitions</code> property.</p>"},{"location":"SPT_Base_Types/functionblocks.html#abortimmediateerror","title":"AbortImmediateError()","text":"<p><pre><code>METHOD PROTECTED AbortImmediateError\nVAR_INPUT\n    Name     : STRING;\n    IsModule : BOOL;\nEND_VAR\n</code></pre> <code>Name</code> will be included in the event text.  If <code>IsModule</code> is <code>TRUE</code>, a SubModuleError is raised.  If <code>FALSE</code> a ComponentError is raised.</p>"},{"location":"SPT_Base_Types/functionblocks.html#hmi","title":"HMI","text":"Method Return Type Access Description AllowHMIControl null PROTECTED Signal to this module that external functions via HMI should be allowed BlockHMIControl null PROTECTED Signal to this module that external functions via HMI should be blocked HMICommunication null PROTECTED Called cyclically; Handles HMI command requests HMIPermissions null PROTECTED Called cyclically; sets whether or not HMI commands are allowed based on current PackML mode <p>Notes AllowHMIControl() <pre><code>METHOD PROTECTED FINAL AllowHMIControl\nVAR_INPUT\n    ThisModuleOnly : BOOL; //! If TRUE, only the PackML module itself is controllable. If FALSE, all components become controllable as well\nEND_VAR\n</code></pre></p> <p>HMICommunication() <code>METHOD PROTECTED HMICommunication</code></p> <p>Override and <code>SUPER^</code> call this method to implement component-specific HMI commands, status, configuration items.  The base method uses a predefined local <code>HMICommandActive_Descendant</code> as an interlock to ensure only one command is fired at a time, whether it's a base command or a component-specific command.  The base method also provides <code>HMICommandActive_Base</code> for you to use in your custom method extensions.</p> <p>Example</p> <pre><code>SUPER^.HMICommunication();\nHMICommand_MyEquipmentModule_RT(CLK := (PackMLBaseModule_HMI.Status.HMIControlAvailable AND NOT HMICommandActive_Base) AND (MyEquipmentModule_HMI.Command.MyCommand XOR MyEquipmentModule_HMI.Command.MyOtherCommand));\n\n//Signal to FB_PackMLBaseModule that a command is active\nHMICommandActive_Descendant := PackMLBaseModule_HMI.Status.HMIControlAvailable AND (MyEquipmentModule_HMI.Command.MyCommand OR MyEquipmentModule_HMI.Command.MyOtherCommand);\n\n//Process Momentary HMI requests\nIF HMICommand_MyEquipmentModule_RT.Q THEN\n    IF MyEquipmentModule_HMI.Command.MyCommand THEN\n        MyCommand();\n    ELSIF MyEquipmentModule_HMI.Command.MyOtherCommand THEN\n        MyOtherCommand();\n    END_IF\nEND_IF\n\n//Update HMI status info\nMyEquipmentModule_HMI.Status.Red   := Red;\nMyEquipmentModule_HMI.Status.Green := Green;\nMyEquipmentModule_HMI.Status.Blue  := Blue;\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#monitoring_1","title":"Monitoring","text":"Method Return Type Access Description ComponentMonitor null PROTECTED Called cyclically; checks components for faults and calls appropriate reaction method SubModuleMonitor null PROTECTED Called cyclically; checks submodules for faults and calls appropriate reaction method"},{"location":"SPT_Base_Types/functionblocks.html#primary-acting-states","title":"Primary &amp; Acting States","text":"Method Return Type Access Description Aborted null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Aborted</code> Complete null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Complete</code> Execute null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Execute</code> Held null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Held</code> Idle null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Idle</code> Stopped null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Stopped</code> Suspended null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Suspended</code> Undefined null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Undefined</code>.  Should not normally be called. Aborting null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Aborting</code> Clearing null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Clearing</code> Completing null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Completing</code> Holding null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Holding</code> Resetting null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Resetting</code> Starting null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Starting</code> Stopping null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Stopping</code> Suspending null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Suspending</code> Unholding null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Unholding</code> Unsuspending null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Unsuspending</code> <p>Info</p> <p>The private method <code>StateControl</code> will automatically call the method that corresponds with the module's PackML state.  These methods are typically overriden and replaced with customized machine logic.</p> <p>Set <code>NoStateTasksToComplete</code> to <code>TRUE</code> to indicate to the state sequencer that there are things left to do before advancing states.  Set <code>StateTasksComplete</code> when your machine logic is completed.  Both of these variables are reinitialized when the state is advanced, so no additional management is necessary.</p> <p>Call <code>SUPER^.</code>State() at the end of your method override so that the base method can take care of housekeeping.</p> <p>Example</p> <pre><code>METHOD PROTECTED FINAL Clearing\n\nCASE SequenceState OF\n    0:\n        NoStateTasksToComplete := FALSE;\n        SequenceState          := SequenceState + 10;\n    10:\n        //Reset any alarms that get latched\n        UnwindAlarms[E_Unwind.StartTimeout].Clear(0, 0);\n        SequenceState := SequenceState + 10;\n    20:\n        // Enable here\n        Axis.Enable();\n\n        // Check enabled here\n        IF Axis.Enabled THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n    30:\n        StateTasksComplete := TRUE;\nEND_CASE\n\nSUPER^.Clearing();\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#fb_tracelog","title":"FB_TraceLog","text":"<p>(Global-declared in library GVL <code>Tracing</code>)</p> <p>Provides methods for adding events to the trace log.  Includes throttling mechanism to limit the number of events per PLC scan (default 100 per scan; see Parameters_Tracing).</p> <p>Automatically collects context information which is appended to the JSON attribute of the event which is raised.</p> <p>Example message</p> <p></p> <p>JSON attribute</p> <p></p>"},{"location":"SPT_Base_Types/functionblocks.html#methods_2","title":"Methods","text":"Method Return Type Access Description AddEntry null PUBLIC Adds a basic message to the trace log AddEntryWithJson null PUBLIC Adds a message to the trace log and appends a given JSON object the event attributes"},{"location":"SPT_Base_Types/functionblocks.html#addentry","title":"AddEntry()","text":"<pre><code>METHOD PUBLIC AddEntry\nVAR_INPUT\n    Source  : T_MaxString;\n    Message : T_MaxString;\n    Flags   : UDINT;\nEND_VAR\n</code></pre> <p><code>Source</code> should be used to specify where the trace message is coming from (FB name, etc.)  This is handled automatically for you if using the wrapper methods in <code>FB_BaseFB</code>.  <code>Message</code> is the the textual description of your event.  <code>Flags</code> has no defined purpose but can be used, for instance, to signal to listeners that this event should be highlighted or handled in a different way.</p>"},{"location":"SPT_Base_Types/functionblocks.html#addentrywithjson","title":"AddEntryWithJson()","text":"<pre><code>METHOD PUBLIC AddEntryWithJson\nVAR_INPUT\n    Source  : T_MaxString;\n    Message : T_MaxString;\n    Flags   : UDINT;\n    Json    : T_MaxString;\nEND_VAR\n</code></pre> <p>Behaves exactly the same way as <code>AddEntry()</code> but takes an additional argument <code>Json</code> which will be automatically appended to the JSON attribute of the event (<code>ExtendedInfo</code>).  This can be used to provide even more contextual information than is automatically provided.</p>"},{"location":"SPT_Base_Types/globals.html","title":"Globals/Parameters","text":""},{"location":"SPT_Base_Types/globals.html#parameters","title":"Parameters","text":""},{"location":"SPT_Base_Types/globals.html#parameters_packml_base","title":"Parameters_PackML_Base","text":"Parameter Type Default Description MAX_NO_OF_SUBMODULES UDINT 20 Maximum number of submodules that can be registered MAX_NO_OF_COMPONENTS UDINT 32 Maximum number of components per submodule MAX_NO_OF_EXTERNAL_CONTROLLERS UDINT 10 Maximum number of I_PackML_ExternalController that can be registered with a submodule UNIT_MODE_DEFAULT E_PMLUnitMode ePMLUnitMode_Production Default mode set to all submodules upon initialization UNIT_STATE_DEFAULT E_PMLCommand ePMLCommand_Abort Default command which is set to all submodules upon initialization"},{"location":"SPT_Base_Types/globals.html#parameters_tracing","title":"Parameters_Tracing","text":"Parameter Type Default Description TRACING_ENABLED BOOL TRUE Set <code>FALSE</code> to disable all tracing functions (ex. machine in production) MAX_LOG_ENTRIES_PER_SCAN UDINT 100 Specify maximum number of messages allowed to be sent per PLC scan"},{"location":"SPT_Base_Types/globals.html#gvls","title":"GVLs","text":""},{"location":"SPT_Base_Types/globals.html#tracing","title":"Tracing","text":"<pre><code>{attribute 'qualified_only'}\nVAR_GLOBAL\n    GlobalTraceLog : FB_TraceLog;\nEND_VAR\n</code></pre>"},{"location":"SPT_Base_Types/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_Base_Types/interfaces.html#framework-base","title":"Framework Base","text":""},{"location":"SPT_Base_Types/interfaces.html#i_basefb","title":"I_BaseFB","text":"<p>Defines the most basic functionality of any function block used within the framework</p>"},{"location":"SPT_Base_Types/interfaces.html#properties","title":"Properties","text":"Property Type Access Description Busy BOOL R Function block is performing some action Error BOOL R Function block has encountered an error condition ErrorID UDINT R Error-specific identifier"},{"location":"SPT_Base_Types/interfaces.html#i_cyclicfb","title":"I_CyclicFB","text":"<p>(extends <code>I_BaseFB</code>)</p> <p>Adds to <code>I_BaseFB</code> the concept of initialization, as well as a unified entry point for cyclical code to be called.  You may have collections of <code>I_CyclicFB</code> which are iterated through, calling <code>CyclicLogic()</code> on each.</p>"},{"location":"SPT_Base_Types/interfaces.html#properties_1","title":"Properties","text":"Property Type Access Description InitComplete BOOL R Flag indicating that the function block is ready to use"},{"location":"SPT_Base_Types/interfaces.html#methods","title":"Methods","text":"Method Return Type Description CyclicLogic null Entry point for code execution"},{"location":"SPT_Base_Types/interfaces.html#component-base","title":"Component Base","text":""},{"location":"SPT_Base_Types/interfaces.html#i_componentbase","title":"I_ComponentBase","text":"<p>(extends <code>I_CyclicFB</code>)</p> <p>Defines basic required functionality for component-level function blocks</p> <p>Note</p> <p>This interface was previously located in the SPT_Component_Base library.  It was consolidated into this library as of v3.1.0.  Previous library releases are still included in this repository but are no longer maintained.</p> <p>Info</p> <p>See I_BaseFB for more information.</p>"},{"location":"SPT_Base_Types/interfaces.html#properties_2","title":"Properties","text":"Property Type Access Description CurrentAlarmSeverity TcEventSeverity R Returns the highest severity of any currently active events InSimulation BOOL RW Flag to indicate to component/parent that this component is running simulation code (defined per component) Name STRING RW Name of this component ParentResponseDefinitions ARRAY[0..4] OF E_AlarmResponse RW Defines how the parent of this component should react to each event severity"},{"location":"SPT_Base_Types/interfaces.html#parentresponsedefinitions","title":"ParentResponseDefinitions","text":"<p><code>PROPERTY ParentResponseDefinitions : ARRAY[0..4] OF E_AlarmResponse</code></p> <p>The expected response type of a component's parent can be specified.  The actual response logic is determined by the component's parent.  The parent should observe <code>CurrentAlarmSeverity</code> and then decide what to do in response.</p> <p>Example</p> <pre><code>ParentResponseDefinitions[TcEventSeverity.Verbose]  := E_AlarmResponse.NoResponse;\nParentResponseDefinitions[TcEventSeverity.Info]     := E_AlarmResponse.NoResponse;\nParentResponseDefinitions[TcEventSeverity.Warning]  := E_AlarmResponse.Suspend_Immediate;\nParentResponseDefinitions[TcEventSeverity.Error]    := E_AlarmResponse.Abort_ImmediateError;\nParentResponseDefinitions[TcEventSeverity.Critical] := E_AlarmResponse.Abort_ImmediateError;\n</code></pre>"},{"location":"SPT_Base_Types/interfaces.html#methods_1","title":"Methods","text":"Method Return Type Description AllowHMIControl null Signal to this component that external functions via HMI should be allowed BlockHMIControl null Signal to this component that external functions via HMI should be blocked Reset BOOL Command this component to execute its fault reset routine"},{"location":"SPT_Base_Types/interfaces.html#packml-base","title":"PackML Base","text":""},{"location":"SPT_Base_Types/interfaces.html#i_packml_basemodule","title":"I_PackML_BaseModule","text":"<p>(extends <code>I_CyclicFB</code>, <code>I_PackML_Control</code>)</p> <p>Defines basic state &amp; mode controls &amp; status information required of all PackML modules (Machine Modules &amp; Equipment Modules)</p> <p>Note</p> <p>This interface was previously located in the SPT_PackML_Base library.  It was consolidated into this library as of v3.1.0.  Previous library releases are still included in this repository but are no longer maintained.</p> <p>Info</p> <p>See I_BaseFB and I_PackML_Control for more information.</p>"},{"location":"SPT_Base_Types/interfaces.html#properties_3","title":"Properties","text":"Property Type Access Description CurrentAlarmSeverity TcEventSeverity R Highest severity of any currently active event(s) LogModeChanges BOOL RW Enable/Disable logging of mode changes LogStateChanges BOOL RW Enable/Disable logging of PackML state changes Name STRING RW Name of this module ParentResponseDefinitions ARRAY[0..4] OF E_AlarmResponse RW Defines how the parent of this module should react to each event severity"},{"location":"SPT_Base_Types/interfaces.html#parentresponsedefinitions_1","title":"ParentResponseDefinitions","text":"<p><code>PROPERTY ParentResponseDefinitions : ARRAY[0..4] OF E_AlarmResponse</code></p> <p>The expected response type of a module's parent can be specified.  The actual response logic is handled by the module's parent.  The parent can observe <code>CurrentAlarmSeverity</code> and then decide what to do in response.</p> <p>Example</p> <pre><code>ParentResponseDefinitions[TcEventSeverity.Verbose]  := E_AlarmResponse.NoResponse;\nParentResponseDefinitions[TcEventSeverity.Info]     := E_AlarmResponse.NoResponse;\nParentResponseDefinitions[TcEventSeverity.Warning]  := E_AlarmResponse.Suspend_Immediate;\nParentResponseDefinitions[TcEventSeverity.Error]    := E_AlarmResponse.Abort_ImmediateError;\nParentResponseDefinitions[TcEventSeverity.Critical] := E_AlarmResponse.Abort_ImmediateError;\n</code></pre>"},{"location":"SPT_Base_Types/interfaces.html#i_packml_control","title":"I_PackML_Control","text":"<p>Defines basic control and feedback mechanisms for control of PackML modules</p> <p>Note</p> <p>This interface was previously located in the SPT_PackML_Base library.  It was consolidated into this library as of v3.1.0.  Previous library releases are still included in this repository but are no longer maintained.</p>"},{"location":"SPT_Base_Types/interfaces.html#properties_4","title":"Properties","text":"Property Type Access Description CurrentMode E_PMLUnitMode R Current PackML mode CurrentState E_PMLState R Current PackML state ModeCommand DINT RW Commanded PackML mode StateCommand E_PMLCommand RW Commanded PackML state <p>Note</p> <p>You can request a mode/state change using the method call <code>ChangeState()</code>/<code>ChangeMode()</code> or by setting the <code>StateCommand</code>/<code>ModeCommand</code> properties; they both do the same thing.</p>"},{"location":"SPT_Base_Types/interfaces.html#methods_2","title":"Methods","text":"Method Return Type Description ChangeMode null Request to enter a given mode ChangeState null Issue a specific PackML state command"},{"location":"SPT_Base_Types/interfaces.html#i_packml_externalcontroller","title":"I_PackML_ExternalController","text":"<p>(extends <code>I_CyclicFB</code>, <code>I_PackML_Control</code>)</p> <p>Defines complete means of external control of a PackML module's commanded mode and state.  A module can have many different external controllers registered with it-these could be pushbutton groups, HMIs, SCADA systems, etc.</p> <p>Note</p> <p>This interface was previously located in the SPT_PackML_Base library.  It was consolidated into this library as of v3.1.0.  Previous library releases are still included in this repository but are no longer maintained.</p> <p>Info</p> <p>See I_CyclicFB and I_PackML_Control for more information.</p> <p>Note</p> <p>See FB_PackML_BaseModule.RegisterExternalController() and See FB_ControlSource for more information.</p>"},{"location":"SPT_Base_Types/interfaces.html#properties_5","title":"Properties","text":"Property Type Access Description Control I_PackML_Control W Interface pointer to control interface of module"},{"location":"SPT_Base_Types/interfaces.html#methods_3","title":"Methods","text":"Method Return Type Description ModeChanged null Serves as a callback notification to external controllers that the module's mode has changed StateChanged null Serves as a callback notification to external controllers that the module's state has changed"},{"location":"SPT_Components/index.html","title":"Overview","text":"<p>Collection of function blocks implementing <code>I_ComponentBase</code>.  All components follow the pattern laid out in HMI DUT Pattern.</p> <p>PackML is not required to be used alongside these components, but they are made to fit directly into FB_PackML_BaseModule.</p>"},{"location":"SPT_Components/index.html#design-notes","title":"Design Notes","text":""},{"location":"SPT_Components/index.html#hmi-dut-pattern","title":"HMI DUT Pattern","text":"<p>If a function block is intended to be controlled via HMI, a DUT should be created to contain:</p> <ul> <li>Configuration Variables</li> <li>Commands</li> <li>Status Information</li> <li>A wrapper DUT should also be created to aggregate these data (see class diagram). </li> </ul> <p>Function blocks inheriting FB_ComponentBase will automatically include basic functions (including a Reset command)--see ComponentBaseHMI in FB_ComponentBase. Similarly, inheriting FB_PackML_BaseModule will give you basic mode/state commands, etc. in PackMLModuleBaseHMI.</p> <p>The idea is to give all components/PackML modules the same basic capabilities. Component or Equipment Module-specific functions should be exposed through their own group of DUTs. This pattern makes the development of User Controls on the HMI side much smoother.</p>"},{"location":"SPT_Components/changelog.html","title":"Changelog","text":""},{"location":"SPT_Components/changelog.html#unreleased","title":"[Unreleased]","text":"<ul> <li>NC superimposed moves</li> </ul>"},{"location":"SPT_Components/changelog.html#310-2023-04-14","title":"[3.1.0] - 2023-04-14","text":""},{"location":"SPT_Components/changelog.html#added","title":"Added","text":"<ul> <li>Unit tests for cylinder components</li> <li>Cylinder events added to PLC external types</li> </ul>"},{"location":"SPT_Components/changelog.html#3051-2023-03-16","title":"[3.0.5.1] - 2023-03-16","text":""},{"location":"SPT_Components/changelog.html#changed","title":"Changed","text":"<ul> <li>Added InhibitFeedPositive/Negative to NC BasicSlave and CamSlave components</li> </ul>"},{"location":"SPT_Components/changelog.html#305-2023-03-15","title":"[3.0.5] - 2023-03-15","text":""},{"location":"SPT_Components/changelog.html#added_1","title":"Added","text":"<ul> <li>Added cylinder components</li> </ul>"},{"location":"SPT_Components/changelog.html#changed_1","title":"Changed","text":"<ul> <li>Added InhibitFeedPositive/Negative to NC BasicAxis component</li> </ul>"},{"location":"SPT_Components/changelog.html#304-2023-01-11","title":"[3.0.4] - 2023-01-11","text":""},{"location":"SPT_Components/changelog.html#added_2","title":"Added","text":"<ul> <li>Added translation texts to CamSlave events</li> </ul>"},{"location":"SPT_Components/changelog.html#303-2022-11-17","title":"[3.0.3] - 2022-11-17","text":""},{"location":"SPT_Components/changelog.html#added_3","title":"Added","text":"<ul> <li>Added FB_Component_CamSlaveAxis</li> <li>Added CONSTANTS GVL to contain alarm counts, etc.</li> </ul>"},{"location":"SPT_Components/changelog.html#fixed","title":"Fixed","text":"<ul> <li>Changed how HomeMethod and ResetMethod are called so that error status is correctly captured</li> </ul>"},{"location":"SPT_Components/changelog.html#removed","title":"Removed","text":"<ul> <li>Parameters_Components removed.</li> </ul>"},{"location":"SPT_Components/changelog.html#302-2022-11-11","title":"[3.0.2] - 2022-11-11","text":""},{"location":"SPT_Components/changelog.html#fixed_1","title":"Fixed","text":"<ul> <li>BasicSlaveAxis alarms were not evaluated for severity.</li> </ul>"},{"location":"SPT_Components/changelog.html#301-2022-10-05","title":"[3.0.1] - 2022-10-05","text":""},{"location":"SPT_Components/changelog.html#changed_2","title":"Changed","text":"<ul> <li>Removed check of gear ratio in FB_Component_BasicSlaveAxis.  Previously would not allow &lt;= 0.  This is allowed now.</li> </ul>"},{"location":"SPT_Components/changelog.html#300-2022-10-05","title":"[3.0.0] - 2022-10-05","text":""},{"location":"SPT_Components/changelog.html#added_4","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_Components/cylinders.html","title":"Cylinders","text":""},{"location":"SPT_Components/cylinders.html#interfaces","title":"Interfaces","text":""},{"location":"SPT_Components/cylinders.html#i_solenoid","title":"I_Solenoid","text":"<p>Defines basic required functionality of all cylinders.</p>"},{"location":"SPT_Components/cylinders.html#properties","title":"Properties","text":"Property Type Access Description Extended BOOL R Returns <code>TRUE</code> if cylinder is extended ExtendedOutput BOOL R Returns <code>TRUE</code> if extend is being commanded ExtendTime LREAL RW Get/Set timeout period for extending (in milliseconds) Retracted BOOL R Returns <code>TRUE</code> if cylinder is retracted RetractOutput BOOL RW Returns <code>TRUE</code> if retract is being commanded RetractTime LREAL RW Get/Set timeout period for retracting (in milliseconds)"},{"location":"SPT_Components/cylinders.html#methods","title":"Methods","text":"Method Return Type Description Extend null Command cylinder to extend Retract null Command cylinder to retract"},{"location":"SPT_Components/cylinders.html#function-blocks","title":"Function Blocks","text":""},{"location":"SPT_Components/cylinders.html#fb_doublesolenoid","title":"FB_DoubleSolenoid","text":"<p>(extends <code>FB_SingleSolenoid</code>)</p> <p>Wrapper function block representing a cylinder with two solenoids controlling extend/retract commands and no feedback.</p>"},{"location":"SPT_Components/cylinders.html#fb_doublesolenoidfeedback","title":"FB_DoubleSolenoidFeedback","text":"<p>(extends <code>FB_DoubleSolenoid</code>)</p> <p>Wrapper function block representing a cylinder with two solenoids controlling extend/retract commands and feedback devices indicating extended/retracted state.  Includes alarms which are thrown if actuator's actual state differs for longer than a timeout period.</p>"},{"location":"SPT_Components/cylinders.html#properties_1","title":"Properties","text":"Property Type Access Description ExtendedInput BOOL W Set the state of the EXTENDED feedback device RetractedInput BOOL W Set the state of the RETRACTED feedback device"},{"location":"SPT_Components/cylinders.html#fb_singlesolenoid","title":"FB_SingleSolenoid","text":"<p>(extends <code>FB_ComponentBase</code>, implements <code>I_Solenoid</code>)</p> <p>Wrapper function block representing a cylinder with single solenoid (on =&gt; extend command) and no feedback.</p>"},{"location":"SPT_Components/cylinders.html#fb_singlesolenoidfeedback","title":"FB_SingleSolenoidFeedback","text":"<p>(extends <code>FB_SingleSolenoid</code>)</p> <p>Wrapper function block representing a cylinder with single solenoid (on =&gt; extend command) and feedback devices indicating extended/retracted state.  Includes alarms which are thrown if actuator's actual state differs for longer than a timeout period.</p>"},{"location":"SPT_Components/cylinders.html#properties_2","title":"Properties","text":"Property Type Access Description ExtendedInput BOOL W Set the state of the EXTENDED feedback device RetractedInput BOOL W Set the state of the RETRACTED feedback device"},{"location":"SPT_Components/cylinders.html#fb_solenoidbankbase","title":"FB_SolenoidBankBase","text":"<p>(<code>ABSTRACT</code>, extends <code>FB_ComponentBase</code>)</p> <p>Example Code Available</p> <p>See How to use FB_SolenoidBank for example use case.</p>"},{"location":"SPT_Components/cylinders.html#methods_1","title":"Methods","text":"Method Return Type Access Description AddSolenoid UINT Add a <code>I_Solenoid</code> to the bank"},{"location":"SPT_Components/cylinders.html#addsolenoid","title":"AddSolenoid()","text":"<pre><code>METHOD PUBLIC AddSolenoid : UINT\nVAR_INPUT\n    ipCylinder   : I_Cylinder;\n    Number       : UINT; //This is the number in the IO tree.\n    SolenoidType : E_SolenoidType;\nEND_VAR\n</code></pre>"},{"location":"SPT_Components/cylinders.html#mapio","title":"MapIO()","text":"<p>This is an abstract method that will be used to map the needed IO to the Networked IO. <pre><code>METHOD ABSTRACT MapIO\nVAR\n    x : UINT;\nEND_VAR\n</code></pre></p>"},{"location":"SPT_Components/cylinders.html#duts","title":"DUTs","text":""},{"location":"SPT_Components/cylinders.html#e_solenoidtype","title":"E_SolenoidType","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_SolenoidType : (\n        Single,\n        Double,\n        SingleFeedback,\n        DoubleFeedback\n    );\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/cylinders.html#st_cylinder_hmi","title":"ST_Cylinder_HMI","text":"<pre><code>TYPE ST_Cylinder_HMI :\n    STRUCT\n        Config  : ST_Cylinder_Config;\n        Command : ST_Cylinder_Command;\n        Status  : ST_Cylinder_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/cylinders.html#st_cylinder_command","title":"ST_Cylinder_Command","text":"<pre><code>TYPE ST_Cylinder_Command :\n    STRUCT\n        Extend      : BOOL;\n        Retract     : BOOL;\n        ExtendTime  : LREAL;\n        RetractTime : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/cylinders.html#st_cylinder_config","title":"ST_Cylinder_Config","text":"<pre><code>TYPE ST_Cylinder_Config :\n    STRUCT\n        ExtendTime  : LREAL;\n        RetractTime : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/cylinders.html#st_cylinder_status","title":"ST_Cylinder_Status","text":"<pre><code>TYPE ST_Cylinder_Status :\n    STRUCT\n        Extended   : BOOL;\n        Retracted  : BOOL;\n        Extending  : BOOL;\n        Retracting : BOOL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/cylinders.html#st_solenoidbankconfig","title":"ST_SolenoidBankConfig","text":"<pre><code>TYPE ST_SolenoidBankConfig :\n    STRUCT\n        SolenoidType         : E_SolenoidType;\n        ipSolenoid           : I_Solenoid;\n        SolenoidOutputNumber : UINT;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/cylinders.html#globalsparameters","title":"Globals/Parameters","text":""},{"location":"SPT_Components/cylinders.html#parameters_cylinder","title":"Parameters_Cylinder","text":"Parameter Type Default Description MAX_NUMBER_OF_SOLENOIDS UINT 32 Number of solenoids to be allocated in <code>FB_SolenoidBankBase</code>"},{"location":"SPT_Components/motioncontrol.html","title":"Motion Control","text":""},{"location":"SPT_Components/motioncontrol.html#function-blocks","title":"Function Blocks","text":""},{"location":"SPT_Components/motioncontrol.html#fb_component_basicaxis","title":"FB_Component_BasicAxis","text":"<pre><code>FUNCTION_BLOCK FB_Component_BasicAxis EXTENDS FB_ComponentBase IMPLEMENTS I_BasicAxis\n</code></pre> <p>Wrapper function block adding <code>I_ComponentBase</code> properties and methods to <code>FB_BasicAxis</code>.  All motion method calls have the same signature as <code>FB_BasicAxis</code>.</p> <p>Note</p> <p>See also:     - I_ComponentBase     - I_BasicAxis</p>"},{"location":"SPT_Components/motioncontrol.html#fb_component_basicslaveaxis","title":"FB_Component_BasicSlaveAxis","text":"<pre><code>FUNCTION_BLOCK FB_Component_BasicSlaveAxis EXTENDS FB_ComponentBase IMPLEMENTS I_BasicAxis\n</code></pre> <p>Wrapper function block adding <code>I_ComponentBase</code> properties and methods to <code>FB_BasicSlaveAxis</code>.  All motion method calls have the same signature as <code>FB_BasicAxis</code> and <code>FB_BasicSlaveAxis</code>.</p> <p>Note</p> <p>See also:   - I_ComponentBase   - I_BasicAxis   - I_BasicSlaveAxis</p>"},{"location":"SPT_Components/motioncontrol.html#fb_component_camslaveaxis","title":"FB_Component_CamSlaveAxis","text":"<pre><code>FUNCTION_BLOCK FB_Component_CamSlaveAxis EXTENDS FB_ComponentBase IMPLEMENTS I_CamSlaveAxis\n</code></pre> <p>Wrapper function block adding <code>I_ComponentBase</code> properties and methods to <code>FB_CamSlaveAxis</code>.  All motion method calls have the same signature as <code>FB_BasicAxis</code> and <code>FB_CamSlaveAxis</code>.</p> <p>Note</p> <p>See also:   - I_ComponentBase   - I_BasicAxis   - I_CamSlaveAxis</p>"},{"location":"SPT_Components/motioncontrol.html#duts","title":"DUTs","text":""},{"location":"SPT_Components/motioncontrol.html#st_axisbase_hmi","title":"ST_AxisBase_HMI","text":"<pre><code>TYPE ST_AxisBase_HMI :\n    STRUCT\n        Config  : ST_AxisBase_Config;\n        Command : ST_AxisBase_Command;\n        Status  : ST_AxisBase_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/motioncontrol.html#st_axisbase_command","title":"ST_AxisBase_Command","text":"<pre><code>TYPE ST_AxisBase_Command :\n    STRUCT\n        JogFast_Forward  : BOOL;\n        JogFast_Backward : BOOL;\n        JogSlow_Forward  : BOOL;\n        JogSlow_Backward : BOOL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/motioncontrol.html#st_axisbase_config","title":"ST_AxisBase_Config","text":"<pre><code>TYPE ST_AxisBase_Config :\n    STRUCT\n        JogFastVelocity : LREAL;\n        JogSlowVelocity : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/motioncontrol.html#st_axisbase_status","title":"ST_AxisBase_Status","text":"<pre><code>TYPE ST_AxisBase_Status :\n    STRUCT\n        Enabled              : BOOL;\n        InPosition           : BOOL;\n        Stopped              : BOOL;\n        Coupled              : BOOL;\n        SetPosition          : LREAL;\n        SetPositionModulo    : LREAL;\n        SetVelocity          : LREAL;\n        SetAcceleration      : LREAL;\n        ActualPosition       : LREAL;\n        ActualPositionModulo : LREAL;\n        ActualVelocity       : LREAL;\n        ActualAcceleration   : LREAL;\n        ActualTorque         : LREAL;\n        PositionLag          : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html","title":"Sensors","text":""},{"location":"SPT_Components/sensors.html#interfaces","title":"Interfaces","text":""},{"location":"SPT_Components/sensors.html#i_digitalsensorbase","title":"I_DigitalSensorBase","text":""},{"location":"SPT_Components/sensors.html#properties","title":"Properties","text":"Property Type Access Description DebounceMode E_DebounceMode RW Get/Set the filter to be applied to sensor input DebounceTime BOOL RW Get/Set filter time to be used by <code>DebounceMode</code> Inverted BOOL RW Get/Set if output of sensor should be inverted with respect to its input SimulationInput BOOL RW Get/Set signal to use when component is in simulation mode SimulationMode E_SensorSimulationMode RW Get/Set type of simulation to be used in simulation mode TimeActive TIME RO Get time elapsed since last inactive state TimeInactive TIME RO Get time elapsed since last active state"},{"location":"SPT_Components/sensors.html#function-blocks","title":"Function Blocks","text":""},{"location":"SPT_Components/sensors.html#fb_digitalsensor","title":"FB_DigitalSensor","text":"<p><pre><code>FUNCTION_BLOCK FB_DigitalSensor EXTENDS FB_ComponentBase IMPLEMENTS I_DigitalSensorBase\n</code></pre> Basic digital input processor for digital signals.  Includes locally-defined <code>HardwareInput AT %I* : BOOL</code> for linking to hardware.</p>"},{"location":"SPT_Components/sensors.html#duts","title":"DUTs","text":""},{"location":"SPT_Components/sensors.html#e_debouncemode","title":"E_DebounceMode","text":"<pre><code>TYPE E_DebounceMode : (\n        RawInput,\n        SimpleFlickerFilter,\n        EdgeDetectFilter,\n        MovingAverage\n    ) DINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html#e_sensorsimulationmode","title":"E_SensorSimulationMode","text":"<pre><code>TYPE E_SensorSimulationMode : (\n        InputDriven, //Follows the state of the SimulationInput property\n        Periodic     //Follows a 50% duty cycle at the period specified in ms by SimulationInput);\n    );\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html#st_digitalsensor_hmi","title":"ST_DigitalSensor_HMI","text":"<pre><code>TYPE ST_DigitalSensor_HMI :\n    STRUCT\n        Config  : ST_DigitalSensor_Config;\n        Command : ST_DigitalSensor_Command;\n        Status  : ST_DigitalSensor_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html#st_digitalsensor_command","title":"ST_DigitalSensor_Command","text":"<pre><code>TYPE ST_DigitalSensor_Command :\n    STRUCT\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html#st_digitalsensor_config","title":"ST_DigitalSensor_Config","text":"<pre><code>TYPE ST_DigitalSensor_Config :\n    STRUCT\n        //Status information\n        DebounceMode       : E_DebounceMode;\n        DebounceTime       : TIME;\n        Inverted           : BOOL;\n        SimulationMode     : E_SensorSimulationMode;\n        SimulationTimebase : UINT;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html#st_digitalsensor_status","title":"ST_DigitalSensor_Status","text":"<pre><code>TYPE ST_DigitalSensor_Status :\n    STRUCT\n        Active       : BOOL;\n        TimeActive   : LREAL;\n        TimeInactive : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/examples/solenoidbankbase.html","title":"How to use FB_SolenoidBank","text":""},{"location":"SPT_Components/examples/solenoidbankbase.html#overview","title":"Overview","text":"<p>This function block will allow you to use a network and any number of cylinders to write to the memory as needed.  In this sample, we will use a Festo CPX-FB38 64Byte.  This module from Festo can have many kinds of IO modules, but in this sample, it is only solenoids.</p>"},{"location":"SPT_Components/examples/solenoidbankbase.html#function-block","title":"Function Block","text":"<p>The FB_Festo function block extends from the FB_SolenoidBankBase function block.  Then it adds 64 bytes of input data and 64 bytes of output data.</p> <pre><code>FUNCTION_BLOCK FB_Festo EXTENDS FB_SolenoidBankBase\nVAR\n    //Initial array of cylinders\n    Inputs  AT %I*   : ARRAY[0..63] OF USINT;\n    Outputs AT %Q*   : ARRAY[0..63] OF USINT;\nEND_VAR\n</code></pre>"},{"location":"SPT_Components/examples/solenoidbankbase.html#methods","title":"Methods","text":""},{"location":"SPT_Components/examples/solenoidbankbase.html#mapio","title":"MapIO()","text":"<p>The MapIO method will set the extended output and if there is a retracted output, it will set that one too.  It assumes that the retracted output is the IO point after the extended.</p> <pre><code>SetOutput(Configuration[x].SolenoidOutputNumber,Configuration[x].ipSolenoid.ExtendOutput);\nIF Configuration[x].SolenoidType = E_SolenoidType.Double OR Configuration[x].SolenoidType = E_SolenoidType.DoubleFeedback THEN\n    SetOutput(Configuration[x].SolenoidOutputNumber+1,Configuration[x].ipSolenoid.RetractOutput);\nEND_IF\n</code></pre>"},{"location":"SPT_Components/examples/solenoidbankbase.html#setoutput","title":"SetOutput()","text":"<p>This method will take the number and map it into the correct byte and bit of that byte.  It is called from the <code>MapIO</code> method multiple times.</p> <pre><code>METHOD SetOutput\nVAR_INPUT\n    Output : UINT;\n    Value  : BOOL;\nEND_VAR\n\nVAR\n    myByte    : WORD;\n    myBit     : WORD;\n    myBitMask : USINT;\n    pOutput   : POINTER TO USINT;\nEND_VAR\n</code></pre> <pre><code>// Find the Byte and the Bit of that Byte\nmyByte := Output / 8;\nmyBit  := Output MOD 8;\n\n//Create the mask for to use for turning on/off\nmyBitMask := TO_USINT(EXPT(2, myBit));\n\n//Set the pointer to the byte\npOutput := ADR(Outputs[myByte]);\n\n// Turn on or off as needed the bit of the byte\nIF Value THEN\n    pOutput^ := pOutput^ OR myBitMask;\nELSE\n    pOutput^ := pOutput^ AND (NOT myBitMask);\nEND_IF\n</code></pre>"},{"location":"SPT_Components/examples/solenoidbankbase.html#main-pou","title":"MAIN POU","text":"<p>The main program has all the cylinder variables and the FestoBank.</p> <pre><code>PROGRAM MAIN\nVAR\n    SimpleCylinder  : FB_SingleSolenoid         := (Name := 'Simple Cylinder');\n    SimpleCylinder2 : FB_SingleSolenoid         := (Name := 'Simple Cylinder2');\n    SimpleCylinder3 : FB_SingleSolenoid         := (Name := 'Simple Cylinder3');\n    SimpleCylinder4 : FB_SingleSolenoid         := (Name := 'Simple Cylinder4');\n    SimpleCylinder5 : FB_SingleSolenoid         := (Name := 'Simple Cylinder5');\n    SimpleCylinder6 : FB_SingleSolenoid         := (Name := 'Simple Cylinder6');\n    SimpleCylinder7 : FB_SingleSolenoid         := (Name := 'Simple Cylinder7');\n    SimpleCylinder8 : FB_SingleSolenoid         := (Name := 'Simple Cylinder8');\n    DoubleSolenoid  : FB_DoubleSolenoid         := (Name := 'Dobule Solendoid Cylinder');\n    SingleFeedback  : FB_SingleSolenoidFeedback := (Name := 'Single with Feedback');\n    DoubleFeedback  : FB_DoubleSolenoidFeedback := (Name := 'Double with Feedback');\n\n    //Bank\n    FestoBank : FB_Festo;\n\n    //Init\n    Init : BOOL;\nEND_VAR\n</code></pre>"},{"location":"SPT_Components/examples/solenoidbankbase.html#initialize","title":"Initialize","text":"<p>Here is the cylinder HMI control being allowed and adding the solenoids to the bank.  In the AddSolenoid method, it takes the interface to a cylinder function block, the bit number of the Output and the type of solenoid.  The bit number in this example must be between 0-511 since it is 64 bytes of data.  If the solenoid type is of Double then the retract output is assumed to be right after the extend output.  The AllowHMIControl just give the visualization the ability to extend and retract the cylinders.</p> <p><pre><code>IF NOT Init THEN\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder, Number := 0, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder2, Number := 1, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder3, Number := 2, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder4, Number := 3, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder5, Number := 4, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder6, Number := 5, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder7, Number := 6, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder8, Number := 7, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := DoubleSolenoid, Number := 8, SolenoidType := E_SolenoidType.Double);\n    FestoBank.AddSolenoid(ipCylinder := SingleFeedback, Number := 16, SolenoidType := E_SolenoidType.SingleFeedback);\n    FestoBank.AddSolenoid(ipCylinder := DoubleFeedback, Number := 24, SolenoidType := E_SolenoidType.DoubleFeedback);\n    SimpleCylinder.AllowHMIControl();\n    SimpleCylinder2.AllowHMIControl();\n    SimpleCylinder3.AllowHMIControl();\n    SimpleCylinder4.AllowHMIControl();\n    SimpleCylinder5.AllowHMIControl();\n    SimpleCylinder6.AllowHMIControl();\n    SimpleCylinder7.AllowHMIControl();\n    SimpleCylinder8.AllowHMIControl();\n    DoubleSolenoid.AllowHMIControl();\n    SingleFeedback.AllowHMIControl();\n    DoubleFeedback.AllowHMIControl();\n    Init := TRUE;\nEND_IF\n</code></pre> This is where the cyclicLogic is being called to do the work for the cylinder and the bank of cylinders.  If this was using the full PackML code, these would be in a component array in either the machine module or an equipment module.  </p> <pre><code>SimpleCylinder.CyclicLogic();\nSimpleCylinder2.CyclicLogic();\nSimpleCylinder3.CyclicLogic();\nSimpleCylinder4.CyclicLogic();\nSimpleCylinder5.CyclicLogic();\nSimpleCylinder6.CyclicLogic();\nSimpleCylinder7.CyclicLogic();\nSimpleCylinder8.CyclicLogic();\nDoubleSolenoid.CyclicLogic();\nSingleFeedback.CyclicLogic();\nDoubleFeedback.CyclicLogic();\nFestoBank.CyclicLogic();\n</code></pre>"},{"location":"SPT_Components/examples/solenoidbankbase.html#ethercat-setup","title":"EtherCAT Setup","text":"<p>In this setup, there is one box that is a CPX-FB38 module.  It has the following Process Data. 64 bytes Input and 64 bytes Output  Input Mapping (IB0-IB63)  Output Mapping (QB0-QB63) </p>"},{"location":"SPT_Components/examples/solenoidbankbase.html#notes","title":"Notes","text":"<p>This example was only tested in simulation and the memory checked to see it function.  Once it is tested with real hardware, there may be some slight modifications needed. </p>"},{"location":"SPT_Event_Logger/index.html","title":"Overview","text":"<p>Contain helper functions for interacting with the Tc3_EventLogger library.</p>"},{"location":"SPT_Event_Logger/changelog.html","title":"Changelog","text":""},{"location":"SPT_Event_Logger/changelog.html#unreleased","title":"[Unreleased]","text":""},{"location":"SPT_Event_Logger/changelog.html#300-2022-10-05","title":"[3.0.0] - 2022-10-05","text":""},{"location":"SPT_Event_Logger/changelog.html#added","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_Event_Logger/functions.html","title":"Functions","text":""},{"location":"SPT_Event_Logger/functions.html#f_clearalleventsinclass","title":"F_ClearAllEventsInClass","text":"<pre><code>FUNCTION F_ClearAllEventsInClass\nVAR_IN_OUT\n    Alarms : ARRAY[*] OF FB_TcAlarm; //! Array of Alarms to be defined\nEND_VAR\n</code></pre> <p>Clears any events within <code>Alarms</code> that may have been raised.</p>"},{"location":"SPT_Event_Logger/functions.html#f_createalleventsinclass","title":"F_CreateAllEventsInClass","text":"<p><pre><code>FUNCTION F_CreateAllEventsInClass\nVAR_IN_OUT\n    Alarms : ARRAY[*] OF FB_TcAlarm; //! Array of Alarms to be defined\nEND_VAR\n\nVAR_INPUT\n    ClassSize  : UDINT;                   //! Size in bytes of the event class\n    pInitEvent : POINTER TO TcEventEntry; //! Address of first event in Event Class (Should be the InitReferenceEvent)\n    Prefix     : STRING;                  //! String Prefix for the Event Message -- Usually the Module ID and Name\nEND_VAR\n</code></pre> Initializes all instances of <code>FB_TcAlarm</code> within <code>Alarms</code>.  See BT-2922840077-220922-1646.pdf.</p>"},{"location":"SPT_Event_Logger/functions.html#f_getmaxseverityraised","title":"F_GetMaxSeverityRaised","text":"<pre><code>FUNCTION F_GetMaxSeverityRaised : TcEventSeverity //! Maximum severity\nVAR_IN_OUT\n    Alarms : ARRAY[*] OF FB_TcAlarm; //! Events to compare against\nEND_VAR\n\nVAR_INPUT\n    CurrentSeverity : TcEventSeverity; //! Current severity of module alarm\nEND_VAR\n</code></pre> <p>Returns the highest severity level of any events currently raised within <code>Alarms</code>.</p>"},{"location":"SPT_Event_Logger/functions.html#f_raisealarm","title":"F_RaiseAlarm","text":"<pre><code>FUNCTION F_RaiseAlarm\nVAR_IN_OUT\n    Alarm : FB_TcAlarm; //! Alarm to be raised\nEND_VAR\n</code></pre> <p>Raises event associated with <code>Alarm</code>.</p>"},{"location":"SPT_Event_Logger/functions.html#f_raisealarmandsetflags","title":"F_RaiseAlarmAndSetFlags","text":"<pre><code>FUNCTION F_RaiseAlarmAndSetFlags\nVAR_IN_OUT\n    Alarm     : FB_TcAlarm; //! Alarm to be raised\n    ErrorFlag : BOOL;       //! Error flag to set (VAR_IN_OUT, put the variable you want the function to SET here)\n    ErrorID   : UDINT;      //! Error ID to set (VAR_IN_OUT, put the variable you want the function to SET here) - Will be set using the ID of the given fbAlarm\nEND_VAR\n</code></pre> <p>Raises event associated with <code>Alarm</code>, sets <code>ErrorFlag</code> to <code>TRUE</code>, and copies the eventID associated with <code>Alarm</code> into <code>ErrorID</code>. </p>"},{"location":"SPT_Event_Logger/functions.html#f_raisealarmwithstringparameters","title":"F_RaiseAlarmWithStringParameters","text":"<pre><code>FUNCTION F_RaiseAlarmWithStringParameters\nVAR_IN_OUT\n    Alarm : FB_TcAlarm; //! Alarm to be raised\nEND_VAR\n\nVAR_INPUT\n    String_1 : STRING; //! First string parameter\n    String_2 : STRING; //! Second string parameter\n    String_3 : STRING; //! Third string parameter\nEND_VAR\n</code></pre> <p>Raises event associated with <code>Alarm</code> and passes <code>String_n</code> as arguments for contextual information. </p>"},{"location":"SPT_Event_Logger/functions.html#f_raisealarmwithstringsandflags","title":"F_RaiseAlarmWithStringsAndFlags","text":"<pre><code>FUNCTION F_RaiseAlarmWithStringsAndFlags\nVAR_IN_OUT\n    Alarm     : FB_TcAlarm; //! Alarm to be raised\n    ErrorFlag : BOOL;       //! Error flag to set (VAR_IN_OUT, put the variable you want the function to SET here)\n    ErrorID   : UDINT;      //! Error ID to set (VAR_IN_OUT, put the variable you want the function to SET here) - Will be set using the ID of the given fbAlarm\nEND_VAR\n\nVAR_INPUT\n    String_1 : STRING; //! First string parameter\n    String_2 : STRING; //! Second string parameter\n    String_3 : STRING; //! Third string parameter\nEND_VAR\n</code></pre> <p>Raises event associated with <code>Alarm</code>, sets <code>ErrorFlag</code> to <code>TRUE</code>, and copies the eventID associated with <code>Alarm</code> into <code>ErrorID</code>.  <code>String_n</code> are passed as arguments for contextual information. </p>"},{"location":"SPT_MotionControl/index.html","title":"Overview","text":"<p>General-purpose NC axis wrapper function blocks.  This function block can be used without any PackML-related functions and does not by itself implement any of the component model interfaces.  Use FB_Component_BasicAxis, FB_Component_BasicSlaveAxis, FB_Component_CamSlaveAxisfor PackML-based projects.</p>"},{"location":"SPT_MotionControl/index.html#class-diagram","title":"Class Diagram","text":""},{"location":"SPT_MotionControl/index.html#basic-axis","title":"Basic Axis","text":"<pre><code>classDiagram\n\n    I_CyclicFB --|&gt; I_BaseFB\n    FB_BaseFB ..|&gt; I_BaseFB    \n    FB_CyclicFB --|&gt; FB_BaseFB\n    FB_CyclicFB ..|&gt; I_CyclicFB\n\n    I_BasicAxis --|&gt; I_CyclicFB   \n    I_BasicAxis --o I_MotionSequence\n    I_MotionSequence --o I_BasicAxis\n\n    I_MotionSequence --|&gt; I_BaseFB\n\n    FB_BasicAxis --|&gt; FB_CyclicFB\n    FB_BasicAxis ..|&gt; I_BasicAxis\n\n\n    class I_BasicAxis{\n        &lt;&lt;Interface&gt;&gt;\n        +LREAL Acceleration\n        +LREAL Deceleration\n        +LREAL Velocity\n        +LREAL Jerk\n        +LREAL ActualAcceleration\n        +LREAL ActualPosition\n        +LREAL ActualPositionModulo\n        +LREAL ActualTorque\n        +LREAL ActualVelocity\n        +LREAL PositionLag\n        +LREAL SetAcceleration\n        +LREAL SetPosition\n        +LREAL SetPositionModulo\n        +LREAL SetVelocity\n        +BOOL Enabled\n        +BOOL InPosition\n        +BOOL Stopped\n        +LREAL Override\n        +REFERENCE TO AXIS_REF Axis\n        +I_MotionSequence HomeMethod\n        +I_MotionSequence ResetMethod\n        +BOOL Disable()\n        +BOOL Enable()\n        +BOOL Home()\n        +BOOL Jog(BOOL JogFW, BOOL JogBW, E_JogMode JogMode, LREAL Position)\n        +BOOL MoveAbsolute(LREAL Position, BOOL AbortPrevious)\n        +BOOL MoveModulo(LREAL Position, MC_Direction Direction, BOOL AbortPrevious)\n        +BOOL MoveRelative(LREAL Distance, BOOL AbortPrevious)\n        +BOOL MoveVelocity(LREAL Velocity, BOOL AbortPrevious)\n        +BOOL Reset()\n        +BOOL Stop()\n        +BOOL WriteBoolParameter(MC_AxisParameter ParameterNumber, BOOL Value)\n        +BOOL WriteParameter(MC_AxisParameter ParameterNumber, LREAL Value)\n    }\n\n\n    class I_BaseFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n    class I_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class I_MotionSequence{\n        &lt;&lt;Interface&gt;&gt;\n        +I_BasicAxis Axis\n        +BOOL Execute()\n    }\n\n    class FB_BaseFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_BasicAxis{\n\n    }</code></pre>"},{"location":"SPT_MotionControl/index.html#basic-slave","title":"Basic Slave","text":"<pre><code>classDiagram\n\n    I_CyclicFB --|&gt; I_BaseFB\n    FB_BaseFB ..|&gt; I_BaseFB    \n    FB_CyclicFB --|&gt; FB_BaseFB\n    FB_CyclicFB ..|&gt; I_CyclicFB\n\n    I_BasicAxis --|&gt; I_CyclicFB   \n\n\n\n    FB_BasicAxis --|&gt; FB_CyclicFB\n    FB_BasicAxis ..|&gt; I_BasicAxis\n\n    I_BasicSlaveAxis --|&gt; I_BasicAxis\n    FB_BasicSlaveAxis --&gt; FB_BasicAxis\n    FB_BasicSlaveAxis ..|&gt; I_BasicSlaveAxis\n\n    class I_BasicSlaveAxis{\n        &lt;&lt;Interface&gt;&gt;\n        +BOOL InGear\n        +REFERENCE TO AXIS_REF Master1\n        +REFERENCE TO AXIS_REF Master2\n        +REFERENCE TO AXIS_REF Master3\n        +REFERENCE TO AXIS_REF Master4\n        +LREAL RatioMaster1\n        +LREAL RatioMaster2\n        +LREAL RatioMaster3\n        +LREAL RatioMaster4\n        BOOL GearIn()\n        BOOL GearOut()\n    }\n\n\n    class I_BasicAxis{\n        &lt;&lt;SPT NC Axis&gt;&gt;\n    }\n\n\n    class I_BaseFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n    class I_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_BaseFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_BasicAxis{\n\n    }</code></pre>"},{"location":"SPT_MotionControl/index.html#cam-slave","title":"Cam Slave","text":"<pre><code>classDiagram\n\n    I_CyclicFB --|&gt; I_BaseFB\n    FB_BaseFB ..|&gt; I_BaseFB    \n    FB_CyclicFB --|&gt; FB_BaseFB\n    FB_CyclicFB ..|&gt; I_CyclicFB\n\n    I_BasicAxis --|&gt; I_CyclicFB   \n\n\n\n    FB_BasicAxis --|&gt; FB_CyclicFB\n    FB_BasicAxis ..|&gt; I_BasicAxis\n\n    I_CamSlaveAxis --|&gt; I_BasicAxis\n    FB_CamSlaveAxis --&gt; FB_BasicAxis\n    FB_CamSlaveAxis ..|&gt; I_CamSlaveAxis\n\n    class I_CamSlaveAxis{\n        &lt;&lt;Interface&gt;&gt;\n        +BOOL InSync\n        +REFERENCE TO AXIS_REF Master\n        +REFERENCE TO ST_CamParameters CamParameters\n        +UDINT RunningTable\n        +LREAL SyncPos\n        BOOL ChangeMode()\n        BOOL FindSlavePos()\n        BOOL FindSyncPos()\n        BOOL StartCouple() \n        BOOL StartSync()\n        BOOL UpdateTable()\n    }\n\n\n    class I_BasicAxis{\n        &lt;&lt;SPT NC Axis&gt;&gt;\n    }\n\n\n    class I_BaseFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n    class I_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_BaseFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_BasicAxis{\n\n    }\n</code></pre>"},{"location":"SPT_MotionControl/changelog.html","title":"Changelog","text":""},{"location":"SPT_MotionControl/changelog.html#unreleased","title":"[Unreleased]","text":""},{"location":"SPT_MotionControl/changelog.html#311-2022-04-25","title":"[3.1.1] - 2022-04-25","text":""},{"location":"SPT_MotionControl/changelog.html#fixed","title":"Fixed","text":"<ul> <li>GetNewFB() in all FB_RingBuffer_xxx function blocks were returning POINTER TO MC_MoveAbsolute</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#310-2022-04-06","title":"[3.1.0] - 2022-04-06","text":""},{"location":"SPT_MotionControl/changelog.html#added","title":"Added","text":"<ul> <li>Initial release</li> <li>Added contents of SPT_NC_Homing library as part of consolidation effort</li> <li>Added contents of SPT_NC_Drives library as part of consolidation effort</li> <li>Added contents of SPT_NC_Axis library as part of consolidation effort</li> <li>Added contents of SPT_NC_Basic_Slave library as part of consolidation effort</li> <li>Added contents of SPT_NC_CamSlave library as part of consolidation effort</li> </ul>"},{"location":"SPT_MotionControl/duts.html","title":"DUTs","text":""},{"location":"SPT_MotionControl/duts.html#enums","title":"ENUMs","text":""},{"location":"SPT_MotionControl/duts.html#e_camaxisstate","title":"E_CamAxisState","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_CamAxisState : (\n        eCamAxisState_Disabled := 0,\n        eCamAxisState_ReadMasterParameters,\n        eCamAxisState_ReadSlaveParameters,\n        eCamAxisState_AxisInitDone,\n        eCamAxisState_WaitForCommand,\n        eCamAxisState_DecoupleBeforeStart,\n        eCamAxisState_CheckTableSelect,\n        eCamAxisState_LoadCamTable,\n        eCamAxisState_CheckAxisStatus,\n        eCamAxisState_ReadSlaveDynamics,\n        eCamAxisState_DetermineSyncMove,\n        eCamAxisState_SlaveSyncMove,\n        eCamAxisState_CoupleSlave,\n        eCamAxisState_SetChangeMode,\n        eCamAxisState_WaitForChangeCommand,\n        eCamAxisState_WriteNewTable,\n        eCamAxisState_WaitForActive,\n        //eCamAxisState_DecoupleSlave,\n\n        //eCamAxisState_HaltSlave,\n        eCamAxisState_Error\n    ) UDINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_MotionControl/duts.html#e_camsyncmode","title":"E_CamSyncMode","text":"<p>When <code>StartSync()</code> is called, a modulo move will be performed to position the slave according to the selected cam table.  <code>ST_CamParameters.SyncMode</code> specifies how this move should be executed. <pre><code>TYPE E_CamSyncMode : (\n        eCamSyncMode_ShortestWay    := 0, // Move the Shortest Distance\n        eCamSyncMode_Forward        := 1, // Move Only in the Forward Direction\n        eCamSyncMode_Reverse        := 2, // Move Only in the Reverse Direction\n        eCamSyncMode_Window_Forward := 3, // Move Shortest Distance If In Window Else Move Forward\n        eCamSyncMode_Window_Reverse := 4  // Move Shortest Distance If In Window Else Move Reverse\n    );\nEND_TYPE\n</code></pre></p>"},{"location":"SPT_MotionControl/duts.html#structs","title":"STRUCTs","text":""},{"location":"SPT_MotionControl/duts.html#st_abshomeparameters","title":"ST_AbsHomeParameters","text":"<pre><code>TYPE ST_AbsHomeParameters :\n    STRUCT\n        PositionBias           : LREAL;\n        PositionLimit_Positive : LREAL;\n        PositionLimit_Negative : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_MotionControl/duts.html#st_camparameters","title":"ST_CamParameters","text":"<pre><code>TYPE ST_CamParameters :\n    STRUCT\n        // Table Must Be Constructed of Motion Functions\n        MasterPos     : LREAL         := 0.1;                                    // Position of Master For Which Corresponding Slave Position Is Found For\n        SyncMode      : E_CamSyncMode := E_CamSyncMode.eCamSyncMode_ShortestWay; // Specifies Which Direction Slave Moves To Synchronize With the Master\n        SyncWindow    : LREAL         := 10.0;                                   // Used In Conjunction With Sync Mode\n        SyncVelocity  : LREAL         := 10.0;                                   // Used When Slave Moves To Synchronization Position\n        SyncAccel     : LREAL         := 100.0;                                  // Used When Slave Moves To Synchronization Position\n        SyncDecel     : LREAL         := 100.0;                                  // Used When Slave Moves To Synchronization Position\n        SyncJerk      : LREAL         := 1000.0;                                 // Used When Slave Moves To Synchronization Position\n        TableSelect   : UDINT         := 1;                                      // Selects Which of Five Cam Tables To Use\n        CamTableId    : MC_CAM_ID     := 1;                                      // Make Sure All Your Id's are Unique\n        CamTable      : ARRAY[1..Parameters_NCCamAxis.CAM_SLAVE_AXIS_TABLES] OF ST_CamPoints;\n        Periodic      : BOOL         := TRUE;\n        MasterOffset  : LREAL        := 0.0;\n        SlaveOffset   : LREAL        := 0.0;\n        MasterScaling : LREAL        := 1.0;\n        SlaveScaling  : LREAL        := 1.0;\n        StartMode     : MC_StartMode := MC_STARTMODE_ABSOLUTE;\n        BufferMode    : MC_BufferMode;\n        CamInOptions  : ST_CamInOptions;\n        ChangeOptions : ST_CamInOptions; // Used for MC_SetCamOnlineChangeMode; Change Mode is Set After Cam In\n    END_STRUCT\nEND_TYPE\nST_CamParameters\n</code></pre>"},{"location":"SPT_MotionControl/duts.html#st_campoints","title":"ST_CamPoints","text":"<pre><code>TYPE ST_CamPoints :\n    STRUCT\n        Points         : ARRAY[1..Parameters_NCCamAxis.CAM_SLAVE_AXIS_MAX_CAM_POINTS] OF MC_MotionFunctionPoint; // Array of Points \n        NumberOfPoints : DINT;                                                                                   // Quantity of Points \n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_MotionControl/duts.html#st_stepblocklagbasedparameters","title":"ST_StepBlockLagBasedParameters","text":"<pre><code>TYPE ST_StepBlockLagBasedParameters :\n    STRUCT\n        Direction              : MC_Home_Direction := mcNegativeDirection;\n        Velocity               : LREAL             := 10;\n        Acceleration           : LREAL             := 100;\n        Deceleration           : LREAL             := 100;\n        Jerk                   : LREAL             := 1000;\n        DetectionVelocityLimit : LREAL             := 5;\n        DetectionVelocityTime  : TIME              := T#500MS;\n        TimeLimit              : TIME;\n        DistanceLimit          : LREAL;\n        TorqueLimit            : LREAL            := 10;\n        LagLimit               : LREAL            := 10;\n        Options                : ST_Home_Options3 := (InstantLagReduction := TRUE);\n    END_STRUCT\nEND_TYPE\n</code></pre> Member Type Description Direction LREAL Enumeration that defines the initial direction of movement for the search procedure Velocity LREAL Maximum travel velocity (&gt;0). Acceleration LREAL Acceleration (\u22650). If the value is 0, the standard acceleration from the axis configuration in the System Manager is used. Deceleration LREAL Deceleration (\u22650). If the value is 0, the standard deceleration from the axis configuration in the System Manager is used. Jerk LREAL Jerk (\u22650). If the value is 0, the standard jerk from the axis configuration in the System Manager is used. DetectionVelocityLimit LREAL Velocity that must be fallen below for the time DetectionVelocityTime in order to detect driving against the fixed stop DetectionVelocityTime LREAL Time for detecting the velocity undershoot when driving against the fixed stop. TimeLimit LREAL Exceeding this time leads to the search procedure being aborted. DistanceLimit LREAL Exceeding this distance in relation to the start position leads to the search procedure being aborted. TorqueLimit LREAL The motor torque is limited to this value, in relation to the weight counterbalance that is possibly parameterized in the drive, in order to avoid mechanical damage. LagLimit LREAL Position lag value which, if exceeded, leads to detection of driving against the fixed stop Options ST_Home_Options3 InstantLagReduction: When referencing to a mechanical fixed stop, the sudden stop produces a position lag in the NC axis, which is dissipated with the parameterized dynamic values in the further course. This can lead to an assumed delay when observing the sequence, but it is purposeful in particular with \"soft\" fixed stops. The position lag is dissipated abruptly by setting this flag"},{"location":"SPT_MotionControl/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_MotionControl/functionblocks.html#axis-types","title":"Axis Types","text":""},{"location":"SPT_MotionControl/functionblocks.html#fb_basicaxis","title":"FB_BasicAxis","text":"<p>(extends <code>FB_CyclicFB</code>, implements <code>I_BasicAxis</code>)</p> <p>Complete implementation of I_BasicAxis.  For use as a PackML component, use <code>FB_Component_BasicAxis</code>.</p> <p>READ ALL OF ME</p> <ul> <li>The <code>Initialize()</code> method checks to see if the underlying AXIS_REF has been linked to an NC axis.  If not, <code>Initialize()</code> will not return <code>TRUE</code>.</li> <li>This behavior can be inhibited by setting the library parameter <code>ALLOW_UNLINKED_NC_AXES</code> to <code>TRUE</code>.</li> <li>The <code>Initialize()</code> method automatically reads all of the axis' NC parameters, which can be accessed via the <code>NCParameters</code> property.</li> <li><code>CyclicLogic()</code> should be called so that underlying function block calls are made</li> <li><code>BOOL</code> return values from command methods should be interpreted as \"COMMAND ACCEPTED\".  This is not \"COMMAND COMPLETED\".  Monitor the <code>Busy</code> property to detect when a command has finished (see example below).</li> <li>Most commands are internally interlocked with <code>_Busy</code> such that a command will not be accepted (return <code>TRUE</code>) if a command is already in process.  This can be bypassed (move interrupted) by passing <code>TRUE</code> to the <code>AbortPrevious</code> argument of the move method call.  If the <code>AbortPrevious</code> argument is not included in the method signature, this should be interpreted to mean the command will take place immediately. </li> </ul>"},{"location":"SPT_MotionControl/functionblocks.html#properties","title":"Properties","text":""},{"location":"SPT_MotionControl/functionblocks.html#axis","title":"Axis","text":"<p><code>PROPERTY Axis : REFERENCE TO AXIS_REF</code></p> <p>Returns a reference to the underlying NC axis for use in other axes or otherwise external motion functions.</p> <p>Example <pre><code>PROGRAM MAIN\nVAR\n    MyBasicAxis : FB_BasicAxis;\n    MyBasicSlaveAxis : FB_BasicSlaveAxis;\n    MySlaveAxis : AXIS_REF;\n    MC_GearIn : MC_GearIn;\nEND_VAR\n\n//Mixing basic MC2 and FB_BasicAxis\nMC_GearIn(\n    Master:= MyBasicAxis.Axis, \n    Slave:= MySlaveAxis, \n    Execute:= TRUE, \n    RatioNumerator:= 1, \n    RatioDenominator:= 1);\n\n//Assigning a FB_BasicAxis to an FB_BasicSlaveAxis\nMyBasicSlaveAxis.Master1 REF= MyBasicAxis.Axis;\n</code></pre></p>"},{"location":"SPT_MotionControl/functionblocks.html#homemethod","title":"HomeMethod","text":"<p><code>PROPERTY HomeMethod : I_MotionSequence</code></p> <p>You can optionally assign an external sequence of events to occur when the <code>Home()</code> method is called.  Assigning a function block which implements <code>I_MotionSequence</code> will automatically assign the axis' <code>AXIS_REF</code> for use in whatever function blocks you choose.  The instantiation of custom home routine function block should take place in the parent of the <code>FB_BasicAxis</code> instance.  </p> <p>Default Home() Behavior</p> <p>The default behavior is to set the current position as zero when this property is not set and <code>Home()</code> is called.  There is an internal instance of FB_HomeRoutine_SetZeroHere which, if not overridden, is call by <code>Home()</code>.</p>"},{"location":"SPT_MotionControl/functionblocks.html#resetmethod","title":"ResetMethod","text":"<p><code>PROPERTY ResetMethod : I_MotionSequence</code></p> <p>You can optionally assign an external sequence of events to occur when the <code>Reset()</code> method is called.  This can be useful, for instance, when using an AX5000 or some drive that needs a separate reset routine to be called in addition to MC_Reset.  Assigning a function block which implements <code>I_MotionSequence</code> will automatically assign the axis' <code>AXIS_REF</code> for use in whatever function blocks you choose.  The instantiation of custom reset routine function block should take place in the parent of the <code>FB_BasicAxis</code> instance.  </p> <p>Default Home() Behavior</p> <p>The default behavior is to call MC_Reset when this property is not set and the Reset() method is called.</p>"},{"location":"SPT_MotionControl/functionblocks.html#methods","title":"Methods","text":""},{"location":"SPT_MotionControl/functionblocks.html#movevelocity","title":"MoveVelocity()","text":"<pre><code>METHOD MoveVelocity : BOOL\nVAR_INPUT\n    Velocity      : LREAL;\n    AbortPrevious : BOOL;\nEND_VAR\n</code></pre> <p>Important</p> <p>The <code>Velocity</code> argument is allowed to be &lt;= 0 (axis will stop--does not call MC_Halt).  The <code>Velocity</code> argument will also be automatically transferred to the <code>Velocity</code> property of the function block!</p>"},{"location":"SPT_MotionControl/functionblocks.html#stop","title":"Stop()","text":"<p><code>METHOD Stop : BOOL</code></p> <p>Important</p> <p><code>Stop()</code> makes a call <code>MC_Halt</code> internally.  <code>MC_Halt</code> can be interruped by a further motion command, whereas <code>MC_Stop</code> cannot.</p>"},{"location":"SPT_MotionControl/functionblocks.html#examples","title":"Examples","text":"Enabling Axis <pre><code>MyAxis.CyclicLogic();\n\nCASE State OF\n  0:\n    IF MyAxis.Enable() THEN\n      State := State + 10;\n    END_IF\n  10:\n    IF MyAxis.Enabled THEN\n      State := State + 10;\n    END_IF\n  20:\n    //Do things \nEND_CASE\n</code></pre> Command a discrete move <pre><code>CASE State OF\n  0:\n    MyAxis.Velocity := 10;\n    IF MyAxis.MoveAbsolute(100, FALSE) THEN\n      State := State + 10;\n    END_IF\n\n  10:\n    IF NOT MyAxis.Busy THEN\n      State := State + 10;\n    END_IF\n\n  20:\n    //More things\nEND_CASE\n</code></pre> Command a velocity move and then change velocity <pre><code>CASE State OF\n  0:\n    IF MyAxis.MoveVelocity(100, FALSE) THEN\n      State := State + 10;\n    END_IF\n\n  10:\n    IF ChangeVelocity THEN\n      MyAxis.MoveVelocity(10, TRUE);\n      State := State + 10;\n    END_IF\n\n  20:\n    //More things\nEND_CASE\n</code></pre> <p>Proper sequencing of multiple axes</p> <p>Resist the temptation to combine commands to multiple axes in the same state/line.  Depending on the command, you can find yourself in a race condition.</p> <p>Less typing, more headaches: <pre><code>CASE State OF\n  0:\n    //Move is issued to both axes--okay\n    IF MyAxis.MoveRelative(10, FALSE) AND MyOtherAxis.MoveRelative(5, FALSE) THEN\n      State := State + 10;\n    END_IF\n  10:\n    //MyOtherAxis finishes its move first and second command is issued\n    //MyAxis is still busy at this point, so command is ignored until first move is complete\n    //Commands end up flip-flopping and axes goes nowhere near where you intended\n    IF MyAxis.MoveRelative(1, FALSE) AND MyOtherAxis.MoveRelative(5, FALSE) THEN\n      State := State + 10;\n    END_IF\n\n  20:\n    //You may or may not ever get here...\n    IF NOT MyAxis.Busy AND NOT MyOtherAxis.Busy THEN\n    State := State + 10;\n    END_IF\nEND_CASE\n</code></pre> Result</p> <p></p> <p>More states, but axes go where you want them to: <pre><code>CASE State OF\n  0:\n    IF MyAxis.MoveRelative(10, FALSE) THEN\n      State := State + 10;\n    END_IF\n  10:\n    IF MyOtherAxis.MoveRelative(5, FALSE) THEN\n      State := State + 10;\n    END_IF\n  20:\n    //Wait for both axes to be done\n    IF NOT MyAxis.Busy AND NOT MyOtherAxis.Busy THEN\n      State := State + 10;\n    END_IF\n  30:\n    IF MyAxis.MoveRelative(1, FALSE) THEN\n      State := State + 10;\n    END_IF\n  40:\n    IF MyOtherAxis.MoveRelative(5, FALSE) THEN\n      State := State + 10;\n    END_IF\n  50:\n    IF NOT MyAxis.Busy AND NOT MyOtherAxis.Busy THEN\n      State := State + 10;\n    END_IF\nEND_CASE\n</code></pre> Result</p> <p></p>"},{"location":"SPT_MotionControl/functionblocks.html#fb_basicslaveaxis","title":"FB_BasicSlaveAxis","text":"<p>(extends <code>FB_BasicAxis</code>, implements <code>I_BasicSlaveAxis</code>)</p> <p>Complete implementation of I_BasicSlaveAxis.  For use as a PackML component, use FB_Component_BasicSlaveAxis.</p> <p>Note</p> <p>See FB_BasicAxis for documentation of base motion funcntions</p>"},{"location":"SPT_MotionControl/functionblocks.html#examples_1","title":"Examples","text":"Couple two axes at 1:1 ratio <pre><code>CASE State OF\n  0:\n    MySlaveAxis.Master1 REF= MyMasterAxis.Axis;\n    MySlaveAxis.RatioMaster1 := 1.0;\n    IF MySlaveAxis.GearIn() THEN\n      State := State + 10;\n    END_IF\n\n  10:\n    IF MySlaveAxis.InGear THEN\n      State := State + 10;\n    END_IF\nEND_CASE\n</code></pre> Adjusting ratio on the fly <pre><code>CASE State OF\n  0:\n    MySlaveAxis.Master1 REF= MyMasterAxis.Axis;\n    MySlaveAxis.RatioMaster1 := 1.0;\n    IF MySlaveAxis.GearIn() THEN\n      State := State + 10;\n    END_IF\n\n  10:\n    IF MySlaveAxis.InGear THEN\n      State := State + 10;\n    END_IF\n\n  20:\n    IF MyMasterAxis.MoveVelocity(100, FALSE) THEN\n      State := State + 10;\n    END_IF\n\n  30:\n    IF AdjustRatio THEN\n      MySlaveAxis.RatioMaster1 := 5.0;\n      State := State + 10;\n    END_IF  \nEND_CASE\n</code></pre> <p>Result</p> <p></p> Phase adjustments using multimaster gearing <p>You can gear a second (and third/fourth) master to the same slave axis.  This can be useful when you need to make phase adjustments to a master/slave coupling (conveyor gapping, etc.)  Moves made to the additional masters are superimposed against the other masters according to the dynamics of the phase adjustment moves. <pre><code>CASE State OF\n  0:\n    MySlaveAxis.Master1 REF= MyMasterAxis.Axis;\n    MySlaveAxis.Master2 REF= MyPhaseAdjustAxis.Axis;\n    MySlaveAxis.RatioMaster1 := 1.0;\n    MySlaveAxis.RatioMaster2 := 1.0;\n\n    IF MySlaveAxis.GearIn() THEN\n      State := State + 10;\n    END_IF\n\n  10:\n    IF MySlaveAxis.InGear THEN\n      State := State + 10;\n    END_IF\n\n  20:\n    //Start master axis\n    IF MyMasterAxis.MoveVelocity(100, FALSE) THEN\n      State := State + 10;\n    END_IF\n  30:\n    IF AdjustPhase THEN\n      //Advance phase of slave by +100 units\n      IF MyPhaseAdjustAxis.MoveRelative(100, FALSE) THEN\n        State := State + 10;\n      END_IF\n    END_IF\n  40:\n    IF NOT MyPhaseAdjustAxis.Busy THEN\n      //Advance phase of slave by -200 units\n      IF MyPhaseAdjustAxis.MoveRelative(-200, FALSE) THEN\n        State := State + 10;\n      END_IF            \n    END_IF\nEND_CASE\n</code></pre></p> <p>Result </p>"},{"location":"SPT_MotionControl/functionblocks.html#fb_camslaveaxis","title":"FB_CamSlaveAxis","text":"<p>(extends <code>FB_BasicAxis</code>, implements <code>I_CamSlaveAxis</code>)</p> <p>Complete implementation of I_CamSlaveAxis.  For use as a PackML component, use <code>FB_Component_CamSlaveAxis</code>.</p> <p>Important</p> <ul> <li>See <code>FB_BasicAxis</code> for documentation of base motion functions</li> <li><code>CamParameters.CamTable[]</code> holds cam definition data for 1 to <code>Parameters_NCCamAxis.CAM_SLAVE_AXIS_TABLES</code> cam tables</li> <li>Each instance of <code>ST_CamPoints</code> holds 1 to <code>1..Parameters_NCCamAxis.CAM_SLAVE_AXIS_MAX_CAM_POINTS</code> of <code>MC_MotionFunctionPoints</code> (see Infosys)</li> <li>Once a slave is coupled to its master, <code>CamParameters.TableSelect</code> specifies which <code>CamParameters.CamTable[]</code> is to be run.  The switch-out happens automatically and according to <code>CamParameters.ChangeOptions</code>.  The default behavior is an instantaneous switch</li> <li>Update <code>CamParameters.ChangeOptions</code> and use <code>ChangeMode()</code> to modify this behavior</li> <li>Table data of the currently running cam can be updated on the fly using <code>UpdateTable()</code> after updating <code>CamParameters.CamTable[]</code>.  Same online change behavior mentioned above applies.</li> </ul>"},{"location":"SPT_MotionControl/functionblocks.html#examples_2","title":"Examples","text":"Hello, Camming! <p><pre><code>CamParameters.CamTableId                              := Slave.Axis.NcToPlc.AxisId;\n\n//Table 1\nCamParameters.CamTable[1].NumberOfPoints              := 3;\nCamParameters.CamTable[1].Points[1].PointIndex        := 1;\nCamParameters.CamTable[1].Points[1].FunctionType      := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5;\nCamParameters.CamTable[1].Points[1].PointType         := MC_MotionPointType.MOTIONPOINTTYPE_REST;\nCamParameters.CamTable[1].Points[1].RelIndexNextPoint := 1;\nCamParameters.CamTable[1].Points[1].MasterPos         := 0.0;\nCamParameters.CamTable[1].Points[1].SlavePos          := 0.0;\nCamParameters.CamTable[1].Points[2].PointIndex        := 2;\nCamParameters.CamTable[1].Points[2].FunctionType      := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5;\nCamParameters.CamTable[1].Points[2].PointType         := MC_MotionPointType.MOTIONPOINTTYPE_TURN;\nCamParameters.CamTable[1].Points[2].RelIndexNextPoint := 1;\nCamParameters.CamTable[1].Points[2].MasterPos         := 180.0;\nCamParameters.CamTable[1].Points[2].SlavePos          := 100.0;\nCamParameters.CamTable[1].Points[3].PointIndex        := 3;\nCamParameters.CamTable[1].Points[3].FunctionType      := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5;\nCamParameters.CamTable[1].Points[3].PointType         := MC_MotionPointType.MOTIONPOINTTYPE_REST;\nCamParameters.CamTable[1].Points[3].RelIndexNextPoint := 0;\nCamParameters.CamTable[1].Points[3].MasterPos         := 360.0;\nCamParameters.CamTable[1].Points[3].SlavePos          := 0.0;\nCamParameters.CamTable[1].NumberOfPoints              := 3;\n</code></pre> Result </p> Coupling above table <p><pre><code>CASE SequenceState OF\n    10:\n        IF Master.Enable() THEN\n            SequenceState := 11;\n        END_IF\n    11:\n        IF Slave.Enable() THEN\n            SequenceState := 12;\n        END_IF\n    12:\n        IF Master.Enabled AND Slave.Enabled THEN\n            SequenceState := 20;\n        END_IF\n    20:\n        IF Slave.StartSync() THEN\n            SequenceState := 21;\n        END_IF\n    21:\n        IF Slave.InSync THEN\n            SequenceState := 22;\n        END_IF\n\n    22:\n        IF Master.MoveVelocity(100, FALSE) THEN\n            SequenceState := 23;\n        END_IF\nEND_CASE\n</code></pre> Result </p> Update Online Change Mode <pre><code>CamParameters.ChangeOptions.ActivationMode := MC_CAMACTIVATION_NEXTCYCLE;\n\nIF Slave.ChangeMode() THEN\n  SequenceState := 0;\nEND_IF\n</code></pre> Change Current Table Point Data <p><pre><code>CamParameters.CamTable[1].Points[2].SlavePos          := 250.0;\n\nIF Slave.UpdateTable() THEN\n  SequenceState := 51;\nEND_IF\n</code></pre> Result </p> Change To Different Table <pre><code>CamParameters.TableSelect := 2;\nIF Slave.RunningTable = 2 THEN\n  SequenceState := 0;\nEND_IF\n</code></pre> <p>Result </p> <p>Pre-Couple Sync Behavior</p> <ul> <li><code>StartSync()</code> is called</li> <li>Correct slave position according to current master position is looked up using <code>MC_ReadCamTableSlaveDynamics</code></li> <li><code>MC_MoveModulo</code> is performed on Slave to bring into sync with master according to cam</li> <li><code>MC_CamIn</code> is executed--slave is now coupled</li> </ul> <p></p> <p>Manually Positioning Slave Prior to Coupling</p> <p>It is possible that you might want to control the pre-couple synchronization move of the slave on your own.  Use <code>FindSyncPos()</code> or <code>FindSlavePos()</code> to do this.  After looking up the sync position and manually moving slave axis, use <code>StartCouple()</code> instead of <code>StartSync()</code>.</p> <p>FindSyncPos() Result </p> <p>FindSlavePos() Use </p>"},{"location":"SPT_MotionControl/functionblocks.html#home-routines","title":"Home Routines","text":""},{"location":"SPT_MotionControl/functionblocks.html#fb_homeroutine_abshoming","title":"FB_HomeRoutine_AbsHoming","text":"<p><pre><code>FUNCTION_BLOCK FINAL FB_HomeRoutine_AbsHoming EXTENDS FB_CyclicFB IMPLEMENTS I_MotionSequence\n</code></pre> Use with multi-turn absolute encoder to make current position read as 0.0 using position bias parameter of the NC encoder object.  A persistent variable of the type ST_AbsHomeParameters must be created along with the FB declaration.  The persistent variable will store the desired value through power cycles. <pre><code>VAR PERSISTENT\n    AbsHomingParms  : ST_AbsHomeParameters;\nEND_VAR\nVAR\n    AbsHoming       : FB_HomeRoutine_AbsHoming;\nEND_VAR\n</code></pre> The initialization code of the application should set the home method and the reference to the parameters variable. <pre><code>Axis.HomeMethod:=AbsHoming;\nAbsHoming.Parameters REF= AbsHomingParms;\n</code></pre> In the Maintenence mode, Execute State, the axis should be manually placed in the desired zero position.  An HMI command can trigger the AbsHoming.Execute method a single time to update the position bias parameter. <pre><code>IF AbsHomeCmd THEN\n    AbsHoming.Execute();\n    AbsHomeCmd:=FALSE;\nEND_IF\n</code></pre></p>"},{"location":"SPT_MotionControl/functionblocks.html#properties_1","title":"Properties","text":"Property Type Access Description Parameters ST_AbsHomeParameters RW Get/Set parameter structure"},{"location":"SPT_MotionControl/functionblocks.html#fb_homeroutine_hardstop","title":"FB_HomeRoutine_HardStop","text":"<pre><code>FUNCTION_BLOCK FINAL FB_HomeRoutine_HardStop EXTENDS FB_CyclicFB IMPLEMENTS I_MotionSequence\n</code></pre> <p>Sets torque limit and moves axis at a set velocity toward specified end of travel.  When a mechanical interference is detected via increasing position lag, sets home to interference position.</p>"},{"location":"SPT_MotionControl/functionblocks.html#properties_2","title":"Properties","text":"Property Type Access Description HomePosition LREAL RW Get/Set position that should be set once hard stop is detected Parameters ST_StepBlockLagBasedParameters RW Get/Set parameter structure"},{"location":"SPT_MotionControl/functionblocks.html#fb_homeroutine_setposition","title":"FB_HomeRoutine_SetPosition","text":"<pre><code>FUNCTION_BLOCK FINAL FB_HomeRoutine_SetPosition EXTENDS FB_CyclicFB IMPLEMENTS I_MotionSequence\n</code></pre> <p>Sets current axis position equal to <code>HomePosition</code> property.</p>"},{"location":"SPT_MotionControl/functionblocks.html#properties_3","title":"Properties","text":"Property Type Access Description HomePosition LREAL RW Get/Set position that should be set"},{"location":"SPT_MotionControl/functionblocks.html#fb_homeroutine_setzerohere","title":"FB_HomeRoutine_SetZeroHere","text":"<pre><code>FUNCTION_BLOCK FINAL FB_HomeRoutine_SetZeroHere EXTENDS FB_CyclicFB IMPLEMENTS I_MotionSequence\n</code></pre> <p>Sets current axis position to 0.0</p>"},{"location":"SPT_MotionControl/functionblocks.html#hardware-utility-function","title":"Hardware Utility Function","text":""},{"location":"SPT_MotionControl/functionblocks.html#fb_resetroutine_coedrive","title":"FB_ResetRoutine_CoEDrive","text":"<pre><code>FUNCTION_BLOCK FINAL FB_ResetRoutine_CoEDrive EXTENDS FB_BaseFB IMPLEMENTS I_MotionSequence\n</code></pre> <p>Issues a basic <code>MC_Reset</code> command against the assigned axis.  Default behavior for <code>FB_BasicAxis</code>, <code>FB_BasicSlaveAxis</code>.</p>"},{"location":"SPT_MotionControl/functionblocks.html#fb_resetroutine_soedrive","title":"FB_ResetRoutine_SoEDrive","text":"<pre><code>FB_ResetRoutine_SoEDrive EXTENDS FB_BaseFB IMPLEMENTS I_MotionSequence\n</code></pre> <p>Issues a SoE reset command, followed by <code>MC_Reset</code>.  For use with AX5000 drives.</p>"},{"location":"SPT_MotionControl/globals.html","title":"Globals/Parameters","text":""},{"location":"SPT_MotionControl/globals.html#parameters","title":"Parameters","text":""},{"location":"SPT_MotionControl/globals.html#parameters_motioncontrol","title":"Parameters_MotionControl","text":"Parameter Type Default Description ALLOW_UNLINKED_NC_AXES BOOL FALSE Allows NC axes to skip checking for linked NC axes during initialization CAM_SLAVE_AXIS_TABLES UDINT 10 Maximum number of cam tables allocated per FB_CamSlaveAxis CAM_SLAVE_AXIS_MAX_CAM_POINTS UDINT 30 Maximum number of cam point allocated per cam table"},{"location":"SPT_MotionControl/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_MotionControl/interfaces.html#i_basicaxis","title":"I_BasicAxis","text":"<p>(extends <code>I_CyclicFB</code>)</p> <p>Defines basic required functionality for a basic NC axis.</p> <p>Tip</p> <p><code>I_BasicAxis</code> does not include any sort of coupling function.  See FB_BasicSlaveAxis and FB_CamSlaveAxis for more information.</p>"},{"location":"SPT_MotionControl/interfaces.html#properties","title":"Properties","text":"Property Type Access Description Axis REFERENCE TO AXIS_REF R Returns an AXIS_REF for use in external motion functions, etc. Override LREAL RW Get/Set axis override (100.0 = 100%) HomeMethod I_MotionSequence W Assign a custom homing method ResetMethod I_MotionSequence W Assign a custom reset method InhibitFeedPositive BOOL W When TRUE, motion in the positive direction is not allowed InhibitFeedNegative BOOL W When TRUE, motion in the negative direction is not allowed"},{"location":"SPT_MotionControl/interfaces.html#dynamics","title":"Dynamics","text":"Property Type Access Description Acceleration LREAL RW Get/Set acceleration input to motion functions Deceleration LREAL RW Get/Set deceleration input to motion functions Jerk LREAL RW Get/Set jerk input to motion functions Velocity LREAL RW Get/Set velocity input to motion functions (exception: <code>MoveVelocity()</code>)"},{"location":"SPT_MotionControl/interfaces.html#feedback","title":"Feedback","text":"Property Type Access Description ActualAcceleration LREAL R Get actual acceleration of axis ActualPosition LREAL R Get actual position of axis ActualPositionModulo LREAL R Get actual modulo position of axis ActualTorque LREAL R Get actual torque of axis ActualVelocity LREAL R Get actual velocity of axis PositionLag LREAL R Get position lag of axis SetAcceleration LREAL R Get setpoint acceleration of axis SetPosition LREAL R Get setpoint position of axis SetPositionModulo LREAL R Get setpoint modulo position of axis SetVelocity LREAL R Get setpoint velocity of axis"},{"location":"SPT_MotionControl/interfaces.html#status","title":"Status","text":"Property Type Access Description Enabled BOOL R Axis is enabled InPosition BOOL R Axis is within target position window Stopped BOOL R Axis is not moving"},{"location":"SPT_MotionControl/interfaces.html#methods","title":"Methods","text":"Method Return Type Description Disable BOOL Disable axis Enable BOOL Enable axis Home BOOL Home axis Jog BOOL Jog axis MoveAbsolute BOOL Initiate an absolute move MoveModulo BOOL Initiate a modulo move MoveRelative BOOL Initiate a relative move MoveVelocity BOOL Initiate a continuous velocity move Reset BOOL Reset axis WriteBoolParameter BOOL Write a parameter of type BOOL WriteParameter BOOL Write a parameter of type LREAL"},{"location":"SPT_MotionControl/interfaces.html#i_basicslaveaxis","title":"I_BasicSlaveAxis","text":"<p>(extends <code>I_BasicAxis</code>)</p> <p>Defines basic required functionality for a basic NC axis plus gearing functions.</p>"},{"location":"SPT_MotionControl/interfaces.html#properties_1","title":"Properties","text":"Property Type Access Description Master1 REFERENCE TO AXIS_REF RW Get/Set the first master axis to couple with Master2 REFERENCE TO AXIS_REF RW Get/Set the second master axis to couple with Master3 REFERENCE TO AXIS_REF RW Get/Set the third master axis to couple with Master4 REFERENCE TO AXIS_REF RW Get/Set the fourth master axis to couple with RatioMaster1 LREAL RW Get/Set the coupling ratio of the first master axis RatioMaster2 LREAL RW Get/Set the coupling ratio of the second master axis RatioMaster3 LREAL RW Get/Set the coupling ratio of the third master axis RatioMaster4 LREAL RW Get/Set the coupling ratio of the fourth master axis InGear LREAL R Get coupling status of this axis"},{"location":"SPT_MotionControl/interfaces.html#methods_1","title":"Methods","text":"Method Return Type Description GearIn BOOL Establish coupling with master axes GearOut BOOL Release the coupling with master axes"},{"location":"SPT_MotionControl/interfaces.html#i_camslaveaxis","title":"I_CamSlaveAxis","text":"<p>(extends <code>I_BasicAxis</code>)</p> <p>Defines basic required functionality for a basic NC axis plus camming functions.</p>"},{"location":"SPT_MotionControl/interfaces.html#properties_2","title":"Properties","text":"Property Type Access Description Master REFERENCE TO AXIS_REF RW Get/Set the master axis CamParameters REFERENCE TO ST_CamParameters RW Get/Set the parameter structure for cam definition, options, etc.  MUST BE SET USING REF= RunningTable UDINT RO Returns the index within <code>CamParameters.CamTable</code> is currently running SyncPos LREAL RO Returns the slave position that corresponds to either the current master position (<code>FindSyncPos()</code>) or a specified master position (<code>FindSlavePosition()</code>), depending on which method was called InSync BOOL RO Get synchronization status of this axis"},{"location":"SPT_MotionControl/interfaces.html#methods_2","title":"Methods","text":"Method Return Type Description ChangeMode BOOL Establish coupling with master axes FindSlavePos BOOL Loads a cam table and reports the corresponding slave position (via <code>SyncPos</code>) when the master is at <code>CamParameters.MasterPos</code> FindSyncPos BOOL Loads a cam table and reports the corresponding slave position (via <code>SyncPos</code>) according to the master's current position StartCouple BOOL Couple the slave to the master without performing any sync move StartSync BOOL Couple the slave to the master after performing an initial synchronization move to align the slave with the current master position UpdateTable BOOL Online update of the current cam's point definitions"},{"location":"SPT_MotionControl/interfaces.html#i_motionsequence","title":"I_MotionSequence","text":"<p>(extends <code>I_BaseFB</code>)</p> <p>Defines basic required functionality for external sequence of any sort.</p>"},{"location":"SPT_MotionControl/interfaces.html#properties_3","title":"Properties","text":"Property Type Access Description Axis I_BasicAxis RW Get/Set axis to be controlled by the sequence"},{"location":"SPT_MotionControl/interfaces.html#methods_3","title":"Methods","text":"Method Return Type Description Execute BOOL Start the sequence"},{"location":"SPT_Utilities/index.html","title":"Overview","text":"<p>Miscellaneous functions and function blocks for a variety of common tasks.</p>"},{"location":"SPT_Utilities/changelog.html","title":"Changelog","text":""},{"location":"SPT_Utilities/changelog.html#unreleased","title":"[Unreleased]","text":""},{"location":"SPT_Utilities/changelog.html#302-2023-04-06","title":"[3.0.2] - 2023-04-06","text":""},{"location":"SPT_Utilities/changelog.html#added","title":"Added","text":"<ul> <li>Moved Tracing listener interfaces and function blocks from SPT_Tracing library (now deprecated)</li> <li>Added FB_SimpleRateLimiter</li> </ul>"},{"location":"SPT_Utilities/changelog.html#301-2022-10-18","title":"[3.0.1] - 2022-10-18","text":""},{"location":"SPT_Utilities/changelog.html#added_1","title":"Added","text":"<ul> <li>Added analog scaling function F_ApplyScaling</li> </ul>"},{"location":"SPT_Utilities/changelog.html#300-2022-10-05","title":"[3.0.0] - 2022-10-05","text":""},{"location":"SPT_Utilities/changelog.html#added_2","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_Utilities/duts.html","title":"DUTs","text":""},{"location":"SPT_Utilities/duts.html#st_scalingparameters","title":"ST_ScalingParameters","text":"<pre><code>TYPE ST_ScalingParameters :\n    STRUCT\n        Input_Minimum  : LREAL := 0;\n        Input_Maximum  : LREAL := 100;\n        Output_Minimum : LREAL := 0;\n        Output_Maximum : LREAL := 4096;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Utilities/duts.html#st_tracemessage","title":"ST_TraceMessage","text":"<pre><code>TYPE ST_TraceMessage :\n    STRUCT\n        Timestamp : T_MaxString;\n        Source    : T_MaxString;\n        Context   : T_MaxString;\n        ScanCount : UDINT;\n        Flags     : UDINT;\n        Message   : T_MaxString;\n        Json      : T_MaxString;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Utilities/duts.html#st_tree_indexbased_node","title":"ST_Tree_IndexBased_Node","text":"<pre><code>TYPE ST_Tree_IndexBased_Node :\n    STRUCT\n        Name       : STRING;\n        ChildCount : DINT;\n        Parent     : DINT;\n        Children   : ARRAY[0..15] OF DINT;\n        Depth      : DINT;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Utilities/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_Utilities/functionblocks.html#fb_fifo_ulint_array","title":"FB_FIFO_ULINT_Array","text":""},{"location":"SPT_Utilities/functionblocks.html#properties","title":"Properties","text":"Property Type Access Description EntryCount DINT RO Number of entries currently in buffer LastInValue ULINT RO Newest value in buffer NextOutValue ULINT RO Oldest value in buffer"},{"location":"SPT_Utilities/functionblocks.html#methods","title":"Methods","text":"Method Return Type Access Description AddEntry BOOL PUBLIC Adds a value to the buffer RemoveEntry BOOL PUBLIC Removes the oldest value from the buffer"},{"location":"SPT_Utilities/functionblocks.html#addentry","title":"AddEntry()","text":"<pre><code>METHOD AddEntry : BOOL\n\nVAR_INPUT\n    Entry : ULINT;\nEND_VAR\n</code></pre> <p>Adds <code>Entry</code> to the buffer.  Returns <code>TRUE</code> on success, <code>FALSE</code> if buffer is full.</p>"},{"location":"SPT_Utilities/functionblocks.html#removeentry","title":"RemoveEntry()","text":"<p><code>METHOD RemoveEntry : BOOL</code></p> <p>Removes the oldest value from the buffer.  Returns <code>TRUE</code> on success, <code>FALSE</code> if buffer was already empty.</p>"},{"location":"SPT_Utilities/functionblocks.html#fb_messagelistener","title":"FB_MessageListener","text":"<p>(<code>FINAL</code>, extends <code>Tc3_EventLogger.FB_ListenerBase2</code>)</p> <p>Internal function block whose purpose is to listen to the event logger, filtering only trace messages.  Parses events into <code>ST_TraceMessage</code> which is then passed up to the parent function block via callback (<code>FB_TraceListenerBase</code>).</p>"},{"location":"SPT_Utilities/functionblocks.html#properties_1","title":"Properties","text":"Property Type Access Description Listener I_TraceListener RW Function block who should receive callback when event is raised"},{"location":"SPT_Utilities/functionblocks.html#fb_simpleratelimiter","title":"FB_SimpleRateLimiter","text":"<p>Limits the rate of change of <code>Y</code> toward <code>TargetValue</code> in both the positive and negative direction.</p> <pre><code>FUNCTION_BLOCK FB_SimpleRateLimiter\nVAR_INPUT\n    Enable        : BOOL;\n    TargetValue   : LREAL;\n    Minimum       : LREAL;\n    Maximum       : LREAL;\n    Rate_Increase : LREAL; //Units per second\n    Rate_Decrease : LREAL; //Units per second\nEND_VAR\n\nVAR_OUTPUT\n    Y : LREAL;\nEND_VAR\n</code></pre>"},{"location":"SPT_Utilities/functionblocks.html#fb_tracelistenerbase","title":"FB_TraceListenerBase","text":"<p>(Abstract, extends <code>FB_CyclicFB</code>, implements <code>I_TraceListener</code>)</p> <p>Base trace log listener block which can be inherited to provide alternate means of relaying trace messages.  Contains local instance of <code>FB_MessageListener</code> which will automatically handle event filtering.</p> <p>Note</p> <p>See I_TraceListener and ST_TraceMessage for more information.</p> <p>Why would I want this?</p> <p>Trace messages are always logged by the TC3 Event Logger system.  In some cases, you might want to forward or persist them by some other means. This function block provides an easy mechanism to do this. Create a new function block which extends <code>FB_TraceListenerBase</code> and override the <code>OnTraceReceived()</code> method.  From there you can, for instance, write the messages to a CSV file or send them via REST API to another system.</p>"},{"location":"SPT_Utilities/functionblocks.html#methods_1","title":"Methods","text":"Method Return Type Access Description OnTraceReceived null PUBLIC Abstract callback method to be overridden to implement alternate event handling"},{"location":"SPT_Utilities/functionblocks.html#fb_tree_indexbased","title":"FB_Tree_IndexBased","text":"<p>(Implements <code>I_Tree_IndexBased</code>)</p> <p>Stores parent-child relationships of a 'tree' of nodes by name.</p> <p>Note</p> <p>See I_Tree_IndexBased for more information.</p>"},{"location":"SPT_Utilities/functionblocks.html#methods_2","title":"Methods","text":"Method Return Type Access Description GetIndexByName DINT PUBLIC Returns the node ID of the node with the name specified"},{"location":"SPT_Utilities/functions.html","title":"Functions","text":""},{"location":"SPT_Utilities/functions.html#f_applyscaling","title":"F_ApplyScaling","text":"<p>Generic analog scaling function</p> <p>Note</p> <p>See ST_ScalingParameters for more information.</p> <pre><code>FUNCTION F_ApplyScaling : LREAL\nVAR_INPUT\n    X : LREAL;\n    Parameters : ST_ScalingParameters;\nEND_VAR\n</code></pre>"},{"location":"SPT_Utilities/functions.html#f_comparelreal","title":"F_CompareLREAL","text":"<p>Returns true if <code>Val1</code> and <code>Val2</code> are within +/- <code>Tolerance</code> of each other.</p> <p>Why would I want this?</p> <p>Floating-point values should not be compared directly for equality.  See here for more information.</p> <pre><code>FUNCTION F_CompareLREAL : BOOL\nVAR_INPUT\n    Val1      : LREAL;\n    Val2      : LREAL;\n    Tolerance : LREAL;\nEND_VAR\n</code></pre>"},{"location":"SPT_Utilities/functions.html#f_comparereal","title":"F_CompareREAL","text":"<p>Returns true if <code>Val1</code> and <code>Val2</code> are within +/- <code>Tolerance</code> of each other.</p> <p>Why would I want this?</p> <p>Floating-point values should not be compared directly for equality.  See here for more information.</p> <pre><code>FUNCTION F_CompareREAL : BOOL\nVAR_INPUT\n    Val1      : REAL;\n    Val2      : REAL;\n    Tolerance : REAL;\nEND_VAR\n</code></pre>"},{"location":"SPT_Utilities/functions.html#f_lreal_roundtoplace","title":"F_LREAL_RoundToPlace","text":"<p>Returns <code>In</code> rounded to <code>DecimalPlaces</code>.</p> <pre><code>FUNCTION F_LREAL_RoundToPlace : LREAL //! Rounded number\nVAR_INPUT\n    In            : LREAL; //! Number to be rounded\n    DecimalPlaces : DINT;  //! Number of decimal places\nEND_VAR\n</code></pre>"},{"location":"SPT_Utilities/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_Utilities/interfaces.html#i_tracelistener","title":"I_TraceListener","text":"<p>Defines basic required functionality trace listener function blocks</p> <p>Note</p> <p>See FB_TraceListenerBase for more information.</p>"},{"location":"SPT_Utilities/interfaces.html#methods","title":"Methods","text":"Method Return Type Description OnTraceReceived null Callback which is fired when a trace message has been sent to the event log"},{"location":"SPT_Utilities/interfaces.html#i_tree_indexbased","title":"I_Tree_IndexBased","text":"<p>Defines basic required functionality index-based trees</p> <p>Note</p> <p>See FB_Tree_IndexBased for more information.</p>"},{"location":"SPT_Utilities/interfaces.html#methods_1","title":"Methods","text":"Method Return Type Description AddNodeAsChildByName null Adds a new node to the tree underneath the node specified as by <code>ParentName</code>"},{"location":"SPT_XPlanar/index.html","title":"Overview","text":"<p>A modular XPlanar control component function block with minimal overhead built on the XPlanar Standard and XPlanar Utility libraries that can easily scale to custom and/or larger projects.  This function block can be used within the SPT PackML framework or any other architecture.</p> <p>For screenshots and notes on getting started please refer to the following document. SPT_XPlanar Startup Notes.pdf</p> <p>For and example project refer to the following repository https://github.com/Beckhoff-USA-Community/SPT_XPlanar_Demo</p>"},{"location":"SPT_XPlanar/index.html#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n\n\n\n    FB_Component_XPlanar o--|&gt; FB_XPlanarMover\n    ip --&gt; I_XPlanarMover\n    FB_XPlanarMover ..|&gt; I_XPlanarMover\n    FB_Component_XPlanar o--&gt; FB_XPlanarTrackSegment\n    FB_XPlanarTrackSegment ..|&gt; I_XPlanarTrack\n    ip --&gt; I_XPlanarTrack\n    FB_XPlanarStation ..|&gt; I_XPlanarStation\n    ip --&gt; I_XPlanarStation\n    I_XPlanarMover o--|&gt; I_XPlanarStation\n\n    class FB_Component_XPlanar{\n      BOOL BuildTracks()\n      BOOL CheckMovers()\n      BOOL CheckTilePower()\n      BOOL DisableMovers()\n      BOOL EnableGroup()\n      BOOL EnableMovers(AddToGroup)\n      BOOL EnableTracks(AddToGroup)\n      BOOL MoverRedetect()\n      BOOL Recover()\n      BOOL Reset()\n      CreateEvents()\n      HMICommunication()\n      Monitoring()\n      CyclicLogic()\n    }\n    class I_XPlanarMover{\n      UDINT DestinationID\n      REFERENCE_TO ST_MoveDynamics MoveDynamics\n      STRING MoverID\n      UDINT MoverIndex\n      I_XPlanarMoverStandard std\n      UDINT TrackID\n\n      BOOL Index(LREAL:Distance)\n      BOOL JoinTrack(UDINT:TrackID)\n      BOOL LeaveTrack(LREAL:DestinationX, LREAL:DestinationY)\n      BOOL SendToStation(UDINT:StationID)\n      BOOL Spin(UDINT:NumOfTurns)\n      BOOL SquareUp()\n      BOOL Tilt(LREAL:APosition, LREAL:BPosition)\n      BOOL VerticalMove(LREAL:Position)\n      BOOL Reset()\n      BOOL ClearCmd()\n\n    }\n    class FB_XPlanarMover{\n      CyclicLogic()\n      HMICommunication()\n    }\n    class I_XPlanarStation{\n      BOOL AllowQueing\n      BOOL CanReleaseMover\n      BOOL HasMover\n      BOOL MoverReady\n      BOOL StationComplete\n      UDINT NextStationID\n      UDINT StationID\n      UDINT TrackID\n      UDINT Size\n      REFERENCE_TO ARRAY[1..MOVER_COUNT] OF I_Mover\n      REFERENCE_TO PositionXYC Position\n\n      I_Process ProcessInterface\n      I_Mover CurrentMover\n\n      BOOL Execute()\n    }\n    class FB_XPlanarStation{\n      BOOL Prepare()\n      CyclicLogic()\n      Execute()\n    }\n    class I_XPlanarTrack{\n      BOOL Error\n      STRING ErrorInfo\n      UDINT ID\n      UDINT MoverCount\n      LREAL TrackLength\n      I_TrackStandard ref\n      REFERENCE_TO FB_TrackTable TrackTable\n      MC_PLANAR_TRACK_OPERATION_MODE OpMode\n\n    BOOL Clear()\n    }\n    class FB_XPlanarTrackSegment{\n        BOOL Build()\n        BOOL Clear()\n        CyclicLogic()\n    }\n\n    class ip{\n      Tracks : ARRAY[1..Tc3_XPlanarComponent.Params_XPlanar.maxTrackCount] of I_Track\n      Movers : ARRAY[1..Tc3_XPlanarComponent.Params_XPlanar.moverCount] of I_Mover\n      Stations : ARRAY[1..Tc3_XPlanarComponent.Params_XPlanar.maxNumStations] of I_Station\n    }\n\n</code></pre>"},{"location":"SPT_XPlanar/changelog.html","title":"Changelog","text":""},{"location":"SPT_XPlanar/changelog.html#unreleased","title":"[Unreleased]","text":""},{"location":"SPT_XPlanar/changelog.html#310-2022-04-14","title":"[3.1.0] - 2022-04-14","text":""},{"location":"SPT_XPlanar/changelog.html#added","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_XPlanar/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_XPlanar/functionblocks.html#fb_component_xplanar","title":"FB_Component_XPlanar","text":"<p>(extends <code>FB_ComponentBase</code>) Function block that allows for an implementation of and XPlanar system as a component of a Machine.</p> <p>Note</p> <p>See also:     - I_ComponentBase</p>"},{"location":"SPT_XPlanar/functionblocks.html#notes","title":"Notes","text":"<ul> <li>The <code>CyclicLogic()</code> method should be called every PLC cycle to ensure the XPlanarEnvironment and XPlanarGroup NC objects along with each Movers/Stations/Tracks are cycled properly and statuses updated.  Called inherently if using SPT Framework</li> <li>The <code>Initialize()</code> method sets mover default halt dynamics and sets up all required interfaces pointers and references. Called inherently if using SPT Framework</li> <li>The <code>Reset()</code> method contains and sequence to reset and re-enable faulted movers</li> <li>The <code>CreateEvents()</code> method should be called before operation to initialize configured Event Logger events Called inherently if using SPT Framework</li> <li>The <code>HMICommunication()</code>method should be called to update statuses to the HMI Called inherently if using SPT Framework</li> </ul>"},{"location":"SPT_XPlanar/functionblocks.html#properties","title":"Properties","text":"Property Type Access Description TileCount UDINT R Actual tile count of the XPlanar system Xpu I_TcIoXPlanarProcessingUnit R Access to XPlanar environment and driver functions"},{"location":"SPT_XPlanar/functionblocks.html#methods","title":"Methods","text":"Method Return Type Access Description Abort BOOL PUBLIC Aborting sequence for immediate halting system and disabling movers BuildTracks BOOL PUBLIC Sequence for initializing all configured track segments CheckMovers BOOL PUBLIC Method that can be called to check all valid movers and raise an alarm if a lost mover is detected CheckTilePower BOOL PUBLIC Method that can be called to check DC Link voltage for all tiles and will raise an alarm if not ok EnableGroup BOOL PUBLIC Method used to Enable the XPlanar Group EnableMovers BOOL PUBLIC Method used to Enable all movers with the option of adding them to the XPlanar Group EnableTracks BOOL PUBLIC Method used to Enable all track segments with the option of adding them to the XPlanar Group MoverRedetect BOOL PUBLIC Method used to perform a mover redetect Recover BOOL PUBLIC Method to cylce through the prepare sequence of each station Reset -- -- --"},{"location":"SPT_XPlanar/functionblocks.html#fb_xplanarmover","title":"FB_XPlanarMover","text":"<p>Complete implementation of I_XPlanarMover for control of an XPlanar mover.</p> <p>Note</p> <p>See also:     - I_XPlanarMover</p>"},{"location":"SPT_XPlanar/functionblocks.html#notes_1","title":"Notes","text":"<ul> <li> <p>The <code>CyclicLogic()</code> method is inherently called by the FB_Component_XPlanar parent object and ensures the NC object is cycled properly and updates the component Busy flag</p> </li> <li> <p>The <code>Reset()</code> method should be called to clear any mover faults</p> </li> </ul>"},{"location":"SPT_XPlanar/functionblocks.html#hmicommunication-method","title":"HMICommunication method","text":"<p>The <code>HMICommunication()</code> method should be called to update status of the mover to the HMI. Called inherently if using SPT Framework</p>"},{"location":"SPT_XPlanar/functionblocks.html#fb_xplanarstation","title":"FB_XPlanarStation","text":"<p>Complete implementation of <code>I_XPlanarStation</code> for configuring and controlling a processing point on the XPlanar table.</p> <p>Note</p> <p>See also:     - I_XPlanarStation</p>"},{"location":"SPT_XPlanar/functionblocks.html#notes_2","title":"Notes","text":"<ul> <li> <p>The <code>Recover()</code> method is called by the recovery sequence of the FB_XPlanar parent object and if a mover is in the 'bubble' of the station it will be brought center and joined to the defined track segment of the station (if applicable).</p> </li> <li> <p>The <code>CyclicLogic()</code> method is inherently called by the FB_XPlanar sum up component and continually monitors for a mover to arrive.  </p> </li> <li>As movers pass through the <code>HasMover</code> flag will set, if a mover enters the station and stops the <code>MoverReady</code> flag will be set.</li> </ul>"},{"location":"SPT_XPlanar/functionblocks.html#fb_xplanartracksegment","title":"FB_XPlanarTrackSegment","text":"<p>Complete implementation of <code>I_XPlanarTrack</code> for configuring and building planar track segments in NC</p> <p>Note</p> <p>See also:     - I_XPlanarTrack</p>"},{"location":"SPT_XPlanar/functionblocks.html#notes_3","title":"Notes","text":"<ul> <li> <p>The <code>CyclicLogic()</code> method is inherently called by the FB_XPlanar parent object and ensures the NC object is cycled properly.</p> </li> <li> <p>The <code>Build()</code> method is called by the Build Tracks sequence of the FB_XPlanar parent object and checks the point configuration and initializes the segment with its linked NC group.</p> </li> </ul>"},{"location":"SPT_XPlanar/globals.html","title":"Interface Properties (ip)","text":"<p>Arrays of Mover, Track Segment, and Station interfaces for use within the application.</p> Property Type Access Description Movers ARRAY[1..Tc3_XPlanarStandard.Params_XPlanar.moverCount] of I_XPlanarMover R Access to mover interfaces for higher level objects Stations ARRAY[1..Tc3_XPlanarStandard.Params_XPlanar.maxNumStations] of I_XPlanarStation R Access to station interfaces for higher level objects Tracks ARRAY[1..Tc3_XPlanarStandard.Params_XPlanar.maxTrackCount] of I_XPlanarTrack R Access to track interfaces for higher level objects"},{"location":"SPT_XPlanar/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_XPlanar/interfaces.html#i_xplanarmover","title":"I_XPlanarMover","text":"<p>Defines required functionality for an XPlanar mover.</p>"},{"location":"SPT_XPlanar/interfaces.html#properties","title":"Properties","text":"Property Type Access Description Destination I_XPlanarStation RW Interface pointer for the next station the mover is going to. MoverDynamics ST_MoveDynamics RW Sturcture for move dynamic vars. Velocity, Accel, Decel, Jerk, CA Gap, etc. MoverID STRING(13) R BTN that is assigned to the mover MoverIndex UDINT RW Index number of the mover TrackID UDINT RW Index number of the track segment the mover is currently on std I_XPlanarMoverStandard R Interface to the base library mover functions"},{"location":"SPT_XPlanar/interfaces.html#move-commands","title":"Move Commands","text":"<p>Built in Mover functions that can be easily called from the application.</p> Method Return Type Description ClearCmd BOOL Used to externally reset the internal command state machine Disable BOOL Disables the mover Enable BOOL Enables the mover FreeMove BOOL Command the mover to an XY position on the table Index BOOL Command the mover to rotate a fraction of a turn JoinTrack BOOL Join the mover to a specified Track Segment LeaveTrack BOOL Command mover to un-join its current track segment and move to a specified xy position SendToStation BOOL Send the mover to a desired Station Spin BOOL Rotate the mover a specified number of turns SquareUp BOOL Rotate the mover to its nearest quarter angle Tilt BOOL Tilt the mover on the A and B Axis VerticalMove BOOL Raise or lower the mover on the Z Axis"},{"location":"SPT_XPlanar/interfaces.html#i_xplanarstation","title":"I_XPlanarStation","text":"<p>Defines a specified area of a track where a mover is going to be processed.</p>"},{"location":"SPT_XPlanar/interfaces.html#properties_1","title":"Properties","text":"Property Type Access Description CanReleaseMover BOOL W Immediate area around the station is blocked, do not release mover CurrentMover I_XPlanarMover R Interface pointer to mover currently in the station HasMover BOOL BOOL Station is currently occupied by a mover ID UDINT RW Index number of the station MoverReady BOOL R Mover in station is not busy and ready to command NextStation I_XPlanarStation RW Interface pointer to the next station to send the mover to Positon REFERENCE TO PositionXYC R Reference to the postition of the station on the XPlanar table StationComplete BOOL W Bit for an external process to tell the station that processing is complete and send the mover to the next station ProcessInterface I_Process W Interface pointer for a processing sequence that the mover will perform while in the station AllowQueing BOOL W Bit to tell the station to bypass checking if the next station is blocked and send the mover anyway (basically allow queuing or not) Size UDINT RW Configured station size in mm (default = 240) Track I_Track RW Interface pointer to the track segment the station resides on. (leave 0 if not using tracks)"},{"location":"SPT_XPlanar/interfaces.html#methods","title":"Methods","text":"Method Return Type Description Execute null 'Automatic' function of the station.  Watch for a mover to arrive, execute a process if assigned, and send the mover away Reset BOOL Reset the internal state machine of the station"},{"location":"SPT_XPlanar/interfaces.html#i_xplanartrack","title":"I_XPlanarTrack","text":"<p>Defines functionality of a specified track segment</p>"},{"location":"SPT_XPlanar/interfaces.html#properties_2","title":"Properties","text":"Property Type Access Description Error BOOL R Bit indicating an error occurred during the build process ErrorInfo STRING R Description of error that occurred during build process ID UDINT RW Index number of the segment MoverCount UDINT R Number of movers currently on segment OpMode MC_PLANAR_TRACK_OPERATION_MODE R Current operating mode of the track segment std I_TrackStandard R Interface to the base library track functions TrackLength UDINT R Linear length of track segment in mm TrackTable REFERENCE_TO FB_TrackTable R Reference to the track table for point configuration"},{"location":"SPT_XTS/index.html","title":"Overview","text":"<p>The XPU component serves as a wrapper to functions and classes provided by the Tc3_XTS_Utility library.</p> <p>The intention for the component is to insulate the application programmer from the 'messy middle' of buffering movers, handling relationships between stations, group motion setup and maintenance, etc.</p> <p>Consider an assembly machine utilizing XTS as a product transport mechanism.  An assembly machine typically consists of multiple stations each performing a discrete operation on a part which is moved serially though the machine.  Ideally a team of developers should be able to work on such a machine simultaneously, concerning themselves only with the logic and operations specific to a particular station.  The passing of an XTS mover to and from a station should be secondary to the developer's efforts.  Additionally, the locations of the stations on the machine base should be flexible and otherwise transparent to the developer.</p> <p>The existing XTS configuration tools continue to be utilized.  Station position(s) and number of movers required are parameterized in the XTS Configuration Tool via the Stations section.  The XPU component will collect all of the configured parameters via the Tc3_XTS_Utility library.</p> <p>At the application layer, a station need only implement a relatively lightweight interface <code>I_XTS_ApplicationStation</code> and make itself known to the XPU component.  During initialization, the XPU component will establish the necessary links and assign an instance of <code>I_XTS_InfoStation</code> to the station.  <code>I_XTS_InfoStation</code> is the interface through which a station can request mover(s) from the XPU component.</p>"},{"location":"SPT_XTS/index.html#mover-exchange","title":"Mover Exchange","text":"<p>The function blocks linked to the NC axes corresponding to XTS movers are contained within <code>FB_Component_XPU</code>.  They are each associated via interface pointer with only one <code>InfoStation</code> at a time.  The XPU component maintains a list of stations and their associated \"neighbors\"--one upstream and another downstream.  <code>ApplicationStations</code> and their specific logic dictates when they are done with/need another mover.  They request a mover from their associated <code>InfoStation</code>, which passes this request to the XPU for processing.</p> <p>The movement of a mover's interface pointer from one InfoStation's buffer to another takes place in a single PLC scan.</p> <p>An illustration of this exchange: <pre><code>sequenceDiagram\n    participant DS as Downstream ApplicationStation\n    participant DI as Downstream InfoStation\n    participant X as XPU\n    participant UI as Upstream InfoStation\n    participant US as Upstream ApplicationStation\n\n    Note over DS,DI: Downstream Application Station and &lt;br&gt;Downstream InfoStation know about each other\n\n    DS -&gt;&gt; DI: Get a new mover\n\n    DI-&gt;&gt;X: Give me a mover\n    Note over DI,X: InfoStation passes an interface to itself &lt;br&gt; as an argument to XPU\n    Note over X: XPU matches the interface to &lt;br&gt; its neighbor\n    X-&gt;&gt;UI: Give Downstream InfoStation a mover\n    Note over X,UI: XPU passes interface to Downstream InfoStation\n    Note over US,UI: Upstream Station and Upstream &lt;br&gt;InfoStation know about each other\n    UI-&gt;US: Are you done with this thing?\n    US--&gt;UI: Yeah go ahead and give it away\n    UI--&gt;&gt;DI: I heard you wanted a mover?\n    Note over UI, DI: Upstream InfoStation passes interface to its first mover in queue\n    DI -&gt; DS: Are you sure you want this thing?\n\n    DS --&gt; DI: Yep!\n    Note over DI: Enqueues the mover\n    DI --&gt;&gt; UI: Thanks I'll take it\n    Note over UI: Dequeues the mover\n    UI --&gt;&gt; X: It is done.\n    X --&gt;&gt; DI: Upstream gave you a mover\n    DI --&gt;&gt; DS: OK check your queue\n    Note over DS: Sends new mover to open station position</code></pre></p>"},{"location":"SPT_XTS/index.html#class-diagram","title":"Class Diagram","text":"<p>For illustration only</p> <pre><code>classDiagram\n\n\n    NC --* CAGroup\n    NC --* Axis\n\n    Axis --* SoftDrive\n\n    XtsProcessingUnit -- Mover    \n    XtsProcessingUnit -- Part\n    XtsProcessingUnit -- Track\n\n\n\n\n\n   FB_Component_XPU -- ApplicationStation\n\n\n\n    Part --  FB_Component_XPU\n    Track --  FB_Component_XPU\n    Mover --  FB_Component_XPU\n    CAGroup --  FB_Component_XPU\n    InfoStation --  FB_Component_XPU\n    XtsInfoServer -- InfoStation\n    InfoStation .. ApplicationStation\n\n    Axis -- Mover\n    SoftDrive -- Mover\n\n\n    Mover .. Part\n    Mover .. Track\n    Mover .. CAGroup\n\n\n\n    class FB_Component_XPU{\n        Parts[]\n        Tracks[]\n        Movers[]\n        InfoStations[]\n    }\n\n\n    class ApplicationStation{\n        InfoStation\n        MoverQueue\n    }\n\n    class InfoStation{\n        ApplicationStation\n        MoverQueue\n        StopPositions[]\n        GetMover()\n        GiveMover()\n        TakeMover()\n    }\n\n    class XtsProcessingUnit{\n        &lt;&lt;TcCom&gt;&gt;\n        Parts[]\n        Tracks[]\n        Movers[]\n    }\n\n    class XtsInfoServer {\n        &lt;&lt;TcCom&gt;&gt;\n        InfoStations[]\n    }\n\n    class NC{\n        &lt;&lt;System Manager&gt;&gt;\n    }</code></pre>"},{"location":"SPT_XTS/changelog.html","title":"Changelog","text":""},{"location":"SPT_XTS/changelog.html#unreleased","title":"[Unreleased]","text":"<ul> <li>MC_GearInPosCA functionality</li> <li>Track management functionality</li> </ul>"},{"location":"SPT_XTS/changelog.html#310-2022-04-14","title":"[3.1.0] - 2022-04-14","text":""},{"location":"SPT_XTS/changelog.html#added","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_XTS/duts.html","title":"DUTs","text":""},{"location":"SPT_XTS/duts.html#enums","title":"ENUMs","text":""},{"location":"SPT_XTS/duts.html#e_applicationstationstate","title":"E_ApplicationStationState","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_ApplicationStationState : (\n        eApplicationStationState_Init          := 0,\n        eApplicationStationState_GetMovers     := 1,\n        eApplicationStationState_InProcess     := 2,\n        eApplicationStationState_ReleaseMovers := 4\n    ) DWORD;\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/duts.html#e_colors_argb","title":"E_Colors_ARGB","text":"<pre><code>{attribute 'qualified_only'}\nTYPE E_Colors_ARGB : (\n        Darkred              := 16#FF8B0000, // rgb(139,0,0)\n        Brown                := 16#FFA52A2A, // rgb(165,42,42)\n        Firebrick            := 16#FFB22222, // rgb(178,34,34)\n        Crimson              := 16#FFDC143C, // rgb(220,20,60)\n        Red                  := 16#FFFF0000, // rgb(255,0,0)\n        Tomato               := 16#FFFF6347, // rgb(255,99,71)\n        Coral                := 16#FFFF7F50, // rgb(255,127,80)\n        Indianred            := 16#FFCD5C5C, // rgb(205,92,92)\n        Lightcoral           := 16#FFF08080, // rgb(240,128,128)\n        Darksalmon           := 16#FFE9967A, // rgb(233,150,122)\n        Salmon               := 16#FFFA8072, // rgb(250,128,114)\n        Lightsalmon          := 16#FFFFA07A, // rgb(255,160,122)\n        Orangered            := 16#FFFF4500, // rgb(255,69,0)\n        Darkorange           := 16#FFFF8C00, // rgb(255,140,0)\n        Orange               := 16#FFFFA500, // rgb(255,165,0)\n        Gold                 := 16#FFFFD700, // rgb(255,215,0)\n        Darkgoldenrod        := 16#FFB8860B, // rgb(184,134,11)\n        Goldenrod            := 16#FFDAA520, // rgb(218,165,32)\n        Palegoldenrod        := 16#FFEEE8AA, // rgb(238,232,170)\n        Darkkhaki            := 16#FFBDB76B, // rgb(189,183,107)\n        Khaki                := 16#FFF0E68C, // rgb(240,230,140)\n        Olive                := 16#FF808000, // rgb(128,128,0)\n        Yellow               := 16#FFFFFF00, // rgb(255,255,0)\n        Yellowgreen          := 16#FF9ACD32, // rgb(154,205,50)\n        Darkolivegreen       := 16#FF556B2F, // rgb(85,107,47)\n        Olivedrab            := 16#FF6B8E23, // rgb(107,142,35)\n        Lawngreen            := 16#FF7CFC00, // rgb(124,252,0)\n        Chartreuse           := 16#FF7FFF00, // rgb(127,255,0)\n        Greenyellow          := 16#FFADFF2F, // rgb(173,255,47)\n        Darkgreen            := 16#FF006400, // rgb(0,100,0)\n        Green                := 16#FF008000, // rgb(0,128,0)\n        Forestgreen          := 16#FF228B22, // rgb(34,139,34)\n        Lime                 := 16#FF00FF00, // rgb(0,255,0)\n        Limegreen            := 16#FF32CD32, // rgb(50,205,50)\n        Lightgreen           := 16#FF90EE90, // rgb(144,238,144)\n        Palegreen            := 16#FF98FB98, // rgb(152,251,152)\n        Darkseagreen         := 16#FF8FBC8F, // rgb(143,188,143)\n        Mediumspringgreen    := 16#FF00FA9A, // rgb(0,250,154)\n        Springgreen          := 16#FF00FF7F, // rgb(0,255,127)\n        Seagreen             := 16#FF2E8B57, // rgb(46,139,87)\n        Mediumaquamarine     := 16#FF66CDAA, // rgb(102,205,170)\n        Mediumseagreen       := 16#FF3CB371, // rgb(60,179,113)\n        Lightseagreen        := 16#FF20B2AA, // rgb(32,178,170)\n        Darkslategray        := 16#FF2F4F4F, // rgb(47,79,79)\n        Teal                 := 16#FF008080, // rgb(0,128,128)\n        Darkcyan             := 16#FF008B8B, // rgb(0,139,139)\n        Aqua                 := 16#FF00FFFF, // rgb(0,255,255)\n        Lightcyan            := 16#FFE0FFFF, // rgb(224,255,255)\n        Darkturquoise        := 16#FF00CED1, // rgb(0,206,209)\n        Turquoise            := 16#FF40E0D0, // rgb(64,224,208)\n        Mediumturquoise      := 16#FF48D1CC, // rgb(72,209,204)\n        Paleturquoise        := 16#FFAFEEEE, // rgb(175,238,238)\n        Aquamarine           := 16#FF7FFFD4, // rgb(127,255,212)\n        Powderblue           := 16#FFB0E0E6, // rgb(176,224,230)\n        Cadetblue            := 16#FF5F9EA0, // rgb(95,158,160)\n        Steelblue            := 16#FF4682B4, // rgb(70,130,180)\n        Cornflowerblue       := 16#FF6495ED, // rgb(100,149,237)\n        Deepskyblue          := 16#FF00BFFF, // rgb(0,191,255)\n        Dodgerblue           := 16#FF1E90FF, // rgb(30,144,255)\n        Lightblue            := 16#FFADD8E6, // rgb(173,216,230)\n        Skyblue              := 16#FF87CEEB, // rgb(135,206,235)\n        Lightskyblue         := 16#FF87CEFA, // rgb(135,206,250)\n        Midnightblue         := 16#FF191970, // rgb(25,25,112)\n        Navy                 := 16#FF000080, // rgb(0,0,128)\n        Darkblue             := 16#FF00008B, // rgb(0,0,139)\n        Mediumblue           := 16#FF0000CD, // rgb(0,0,205)\n        Blue                 := 16#FF0000FF, // rgb(0,0,255)\n        Royalblue            := 16#FF4169E1, // rgb(65,105,225)\n        Blueviolet           := 16#FF8A2BE2, // rgb(138,43,226)\n        Indigo               := 16#FF4B0082, // rgb(75,0,130)\n        Darkslateblue        := 16#FF483D8B, // rgb(72,61,139)\n        Slateblue            := 16#FF6A5ACD, // rgb(106,90,205)\n        Mediumslateblue      := 16#FF7B68EE, // rgb(123,104,238)\n        Mediumpurple         := 16#FF9370DB, // rgb(147,112,219)\n        Darkmagenta          := 16#FF8B008B, // rgb(139,0,139)\n        Darkviolet           := 16#FF9400D3, // rgb(148,0,211)\n        Darkorchid           := 16#FF9932CC, // rgb(153,50,204)\n        Mediumorchid         := 16#FFBA55D3, // rgb(186,85,211)\n        Purple               := 16#FF800080, // rgb(128,0,128)\n        Thistle              := 16#FFD8BFD8, // rgb(216,191,216)\n        Plum                 := 16#FFDDA0DD, // rgb(221,160,221)\n        Violet               := 16#FFEE82EE, // rgb(238,130,238)\n        Magenta              := 16#FFFF00FF, // rgb(255,0,255)\n        Orchid               := 16#FFDA70D6, // rgb(218,112,214)\n        Mediumvioletred      := 16#FFC71585, // rgb(199,21,133)\n        Palevioletred        := 16#FFDB7093, // rgb(219,112,147)\n        Deeppink             := 16#FFFF1493, // rgb(255,20,147)\n        Hotpink              := 16#FFFF69B4, // rgb(255,105,180)\n        Lightpink            := 16#FFFFB6C1, // rgb(255,182,193)\n        Pink                 := 16#FFFFC0CB, // rgb(255,192,203)\n        Antiquewhite         := 16#FFFAEBD7, // rgb(250,235,215)\n        Beige                := 16#FFF5F5DC, // rgb(245,245,220)\n        Bisque               := 16#FFFFE4C4, // rgb(255,228,196)\n        Blanchedalmond       := 16#FFFFEBCD, // rgb(255,235,205)\n        Wheat                := 16#FFF5DEB3, // rgb(245,222,179)\n        Cornsilk             := 16#FFFFF8DC, // rgb(255,248,220)\n        Lemonchiffon         := 16#FFFFFACD, // rgb(255,250,205)\n        LightGoldenRodYellow := 16#FFFAFAD2, // rgb(250,250,210)\n        LightYellow          := 16#FFFFFFE0, // rgb(255,255,224)\n        SaddleBrown          := 16#FF8B4513, // rgb(139,69,19)\n        Sienna               := 16#FFA0522D, // rgb(160,82,45)\n        Chocolate            := 16#FFD2691E, // rgb(210,105,30)\n        Peru                 := 16#FFCD853F, // rgb(205,133,63)\n        SandyBrown           := 16#FFF4A460, // rgb(244,164,96)\n        BurlyWood            := 16#FFDEB887, // rgb(222,184,135)\n        RosyBrown            := 16#FFBC8F8F, // rgb(188,143,143)\n        Moccasin             := 16#FFFFE4B5, // rgb(255,228,181)\n        NavajoWhite          := 16#FFFFDEAD, // rgb(255,222,173)\n        PeachPuff            := 16#FFFFDAB9, // rgb(255,218,185)\n        MistyRose            := 16#FFFFE4E1, // rgb(255,228,225)\n        LavenderBlush        := 16#FFFFF0F5, // rgb(255,240,245)\n        Linen                := 16#FFFAF0E6, // rgb(250,240,230)\n        OldLace              := 16#FFFDF5E6, // rgb(253,245,230)\n        PapayaWhip           := 16#FFFFEFD5, // rgb(255,239,213)\n        Seashell             := 16#FFFFF5EE, // rgb(255,245,238)\n        MintCream            := 16#FFF5FFFA, // rgb(245,255,250)\n        SlateGray            := 16#FF708090, // rgb(112,128,144)\n        LightSlateGray       := 16#FF778899, // rgb(119,136,153)\n        LightSteelBlue       := 16#FFB0C4DE, // rgb(176,196,222)\n        Lavender             := 16#FFE6E6FA, // rgb(230,230,250)\n        FloralWhite          := 16#FFFFFAF0, // rgb(255,250,240)\n        AliceBlue            := 16#FFF0F8FF, // rgb(240,248,255)\n        GhostWhite           := 16#FFF8F8FF, // rgb(248,248,255)\n        HoneyDew             := 16#FFF0FFF0, // rgb(240,255,240)\n        Ivory                := 16#FFFFFFF0, // rgb(255,255,240)\n        Azure                := 16#FFF0FFFF, // rgb(240,255,255)\n        Snow                 := 16#FFFFFAFA, // rgb(255,250,250)\n        Black                := 16#FF000000, // rgb(0,0,0)\n        DimGray              := 16#FF696969, // rgb(105,105,105)\n        Gray                 := 16#FF808080, // rgb(128,128,128)\n        DarkGray             := 16#FFA9A9A9, // rgb(169,169,169)\n        Silver               := 16#FFC0C0C0, // rgb(192,192,192)\n        LightGray            := 16#FFD3D3D3, // rgb(211,211,211)\n        Gainsboro            := 16#FFDCDCDC, // rgb(220,220,220)\n        WhiteSmoke           := 16#FFF5F5F5, // rgb(245,245,245)\n        White                := 16#FFFFFFFF  // rgb(255,255,255)\n    ) UDINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/duts.html#e_moverassignmentrecoverysource","title":"E_MoverAssignmentRecoverySource","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_MoverAssignmentRecoverySource : (\n        eMoverAssignmentRecoverySource_NoBackup   := 0,\n        eMoverAssignmentRecoverySource_NOVRAM     := 1,\n        eMoverAssignmentRecoverySource_Persistent := 2\n    );\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/duts.html#e_xtsstate","title":"E_XTSState","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\n{attribute 'to_string'}\nTYPE E_XTSState : (\n        eXTSState_Disabling := 0,\n        eXTSState_Disabled  := 1,\n        eXTSState_Enabling  := 2,\n        eXTSState_Enabled   := 4,\n        eXTSState_Error     := 8,\n        eXTSState_Reset     := 16\n    ) DWORD;\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/duts.html#structs","title":"STRUCTs","text":""},{"location":"SPT_XTS/duts.html#st_movedynamics","title":"ST_MoveDynamics","text":"<pre><code>TYPE ST_MoveDynamics :\n    STRUCT\n        Velocity     : LREAL := 200;\n        Acceleration : LREAL := MC_DEFAULT;\n        Deceleration : LREAL := MC_DEFAULT;\n        Jerk         : LREAL := MC_DEFAULT;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/duts.html#st_xtsstationconfig","title":"ST_XTSStationConfig","text":"<pre><code>TYPE ST_XTSStationConfig :\n    STRUCT\n        IsAQueueStation : BOOL; //Can accept movers on cold start recovery (station limits will be ignored!!)\n        OverrideGap     : BOOL;\n        Gap             : LREAL;\n        Dynamics        : ST_MoveDynamics;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/examplestations.html","title":"Example Stations","text":"<p>While XTS is constantly being used in more complex and interesting ways, many applications are relatively basic: a closed loop with various \"stations\" along the track where movers need to stop and be worked on.  To compensate for differences in the cycle times of these various station processes, intermediate positions are typically specified between these stations where movers can line up and wait for the next station to be free.</p> <p>The <code>SPT_XTS</code> library contains some example implementations of station logic.  These function blocks can be \"plugged in\" directly to <code>FB_Component_XPU</code> and used as-is, or can be easily copied and modified to implement custom application-specific logic.</p>"},{"location":"SPT_XTS/examplestations.html#fb_xts_queuestation","title":"FB_XTS_QueueStation","text":"<p>(<code>FINAL</code>, extends <code>FB_XTS_StationBase</code>)</p> <p>A queue station will always accept movers from an upstream station, as long as the number of currently assigned movers doesn't exceed <code>MaxNumberOfMovers</code>.  Upon accepting a new mover, it is commanded to move to the first Stop Position (any other defined stop positions are ignored) using the dynamics specified in the station configuration.</p> <p>When the downstream station is ready for movers (<code>CanAcceptMovers</code> property = <code>TRUE</code>) the first mover in the buffer is immediately released from the QueueStation and passed to the downstream station.  It's possible that this condition is satisfied before the mover ever arrives at the QueueStation; it could even happen in the same PLC scan where the mover was accepted by the QueueStation.  In this case, the mover will not stop at the QueueStation's Stop Position.</p>"},{"location":"SPT_XTS/examplestations.html#properties","title":"Properties","text":"Property Type Access Description MaxNumberOfMovers UDINT RW Get/Set the maximum number of movers that can be in a queue at a time"},{"location":"SPT_XTS/examplestations.html#overriding-fb_xts_stationbase","title":"Overriding <code>FB_XTS_StationBase</code>","text":"<p>While much of the logic built in to <code>FB_XTS_StationBase</code> is reused, a few things were overridden and modified to create the queue.</p>"},{"location":"SPT_XTS/examplestations.html#canacceptmover","title":"CanAcceptMover","text":"<p>(from I_XTS_ApplicationStation)</p> <p>Queues need to accept incoming movers as long as there is room for them:</p> <p><code>CanAcceptMover := NumberOfAssignedMovers &lt; _MaxNumberOfMovers;</code></p>"},{"location":"SPT_XTS/examplestations.html#canreleasemover","title":"CanReleaseMover","text":"<p>(from I_XTS_ApplicationStation)</p> <p>Queues can always release movers as long as it has one to release:</p> <p><code>CanReleaseMover := NumberOfAssignedMovers &gt; 0;</code></p>"},{"location":"SPT_XTS/examplestations.html#resetting","title":"Resetting()","text":"<p>(from FB_PackML_BaseModule)</p> <p>The base <code>Resetting()</code> logic sends movers to discrete positions according to the Stop Positions configured.  Queues will only send movers to the first Stop Position, allowing collision avoidance to maintain a suitable gap between them:</p> <pre><code>METHOD PROTECTED Resetting\n\n// Need a copy of .Queue so we can index through array\nipMovers := MoverQueue.Queue;\nCASE SequenceState OF\n    0:\n        _Busy := TRUE;\n        MoverTracker.Clear();\n        SequenceState := SequenceState + 10;\n\n    10:\n        //Determine if any movers have been assigned to this station\n        IF NumberOfAssignedMovers &lt;&gt; 0 THEN\n            SequenceState := 100;\n        ELSE\n            SequenceState := 1000;\n        END_IF\n\n    100:\n        MoverTracker.Clear();\n        FOR i := 1 TO NumberOfAssignedMovers DO\n            IF ipMovers[i] &lt;&gt; 0 THEN\n                IF NOT ipMovers[i].Busy THEN\n                    //Queue stations always command movers to position 1\n                    StopPosition := StopPositions[1];\n                    StopPosition := GetStopPosition(StopPosition);\n                    IF ipMovers[i].MoveAbsoluteCA(StopPosition, TRUE, RecoveryMoveComplete) THEN\n                        MoverTracker.Set(i);\n                    END_IF\n                END_IF\n            END_IF\n        END_FOR\n\n        IF MoverTracker.NumberCompleted = NumberOfAssignedMovers THEN\n            RecoveryMoveComplete := TRUE;\n            SequenceState        := 1000;\n        END_IF\n\n    1000:\n        _Busy := FALSE;\n        SUPER^.Resetting();\nEND_CASE\n</code></pre>"},{"location":"SPT_XTS/examplestations.html#execute","title":"Execute()","text":"<p>(from FB_PackML_BaseModule)</p> <p>There is no <code>Execute()</code> logic defined in the base station; that is left up to the application developer.  In the case of a queue, the process in <code>Execute()</code> is to take ownership of a mover from the upstream station and command it to move to the first Stop Position.  There is no additional state machine required; as long as queues are in the Execute state, they are constantly pulling movers from the upstream station.</p> <pre><code>METHOD PROTECTED Execute\n\nGetMovers();\n</code></pre>"},{"location":"SPT_XTS/examplestations.html#getmovers","title":"GetMovers()","text":"<p>(from FB_XTS_StationBase)</p> <p><code>GetMovers()</code> is a helper method which asks the associated InfoStation for a mover and then commands the mover to the first Stop Position.  The actual logic for passing the mover's interface pointer from one station to the next is internal to the InfoStation.  The application need only call <code>GetMover()</code> on the InfoStation and wait for the return value <code>TRUE</code>, at which point the new mover will be available in <code>MoverQueue.LastMover</code>.</p> <pre><code>METHOD PROTECTED GetMovers : BOOL\n\nCASE SequenceState OF\n    0:\n        //Don't combine this with state 20 -- there is a dead scan for method cleanup/returns\n        IF CanAcceptMover THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    10:\n        IF ipInfoStation.GetMover() THEN\n            // Ask for a new mover      \n            SequenceState := SequenceState + 10;\n        END_IF\n\n    20:\n        //Make sure we don't page fault\n        IF MoverQueue.LastMover &lt;&gt; 0 THEN\n            // Call new mover to this station--use only stop position 1\n            StopPosition := StopPositions[1];\n            StopPosition := GetStopPosition(StopPosition);\n            IF MoverQueue.LastMover.MoveAbsoluteCA(StopPosition, TRUE, FALSE) THEN\n                SequenceState := 0;\n            END_IF\n        ELSE\n            SequenceState := 0;\n        END_IF\nEND_CASE\n</code></pre>"},{"location":"SPT_XTS/examplestations.html#fb_xts_simplestation","title":"FB_XTS_SimpleStation","text":"<p>(<code>FINAL</code>, extends <code>FB_XTS_StationBase</code>)</p> <p>SimpleStations have one or many Stop Positions defined by the XTS Configurator.  The number of Stop Positions dictates how many movers the station will accept at a time.  A simple state machine is implemented:</p> <ul> <li>GetMovers will ask the upstream station for movers until there is one mover for each Stop Position in the buffer and they have all arrived at their assigned Stop Position.</li> <li>InProcess starts a timer that simulates the cycle time of a station's intended process</li> <li>ReleaseMovers signals to the downstream station that movers are available and sends them along as requested</li> </ul> <p>Tip</p> <p>For many applications, the logic in <code>FB_XTS_SimpleStation</code> is adequate with the exception of the simulated process timer.  This was the design intent of <code>FB_XTS_StationBase</code>.  By simply extending <code>FB_XTS_StationBase</code> and overriding <code>Execute()</code>, many different application-specific station types can be developed without having to re-write code.</p>"},{"location":"SPT_XTS/examplestations.html#properties_1","title":"Properties","text":"Property Type Access Description SimulatedProcessTime TIME RW Get/Set the preset time for the process simulation timer"},{"location":"SPT_XTS/examplestations.html#overriding-fb_xts_stationbase_1","title":"Overriding <code>FB_XTS_StationBase</code>","text":""},{"location":"SPT_XTS/examplestations.html#execute_1","title":"Execute()","text":"<p>(from FB_PackML_BaseModule)</p> <p>There is no <code>Execute()</code> logic defined in the base station; that is left up to the application developer.  SimpleStations employ a basic state machine.  The <code>GetMovers()</code> method will return <code>TRUE</code> when all required movers have been acquired and are in position ready to be processed.  Note that <code>GetMovers()</code> is defined in <code>FB_XTS_StationBase</code> and is unchanged in SimpleStations.</p> <pre><code>METHOD PROTECTED Execute\n\nCASE StationState OF\n    E_ApplicationStationState.eApplicationStationState_GetMovers:\n        IF NOT _DisableStation THEN\n            IF GetMovers() THEN\n                StationState := E_ApplicationStationState.eApplicationStationState_InProcess;\n            END_IF\n        END_IF\n\n    E_ApplicationStationState.eApplicationStationState_InProcess:\n        ProcessSimulationTimer_TON(IN := NOT _Pause);\n        IF ProcessSimulationTimer_TON.Q THEN\n            ProcessSimulationTimer_TON(IN := FALSE);\n            StationState := E_ApplicationStationState.eApplicationStationState_ReleaseMovers;\n        END_IF\n\n    E_ApplicationStationState.eApplicationStationState_ReleaseMovers:\n        IF (NumberOfAssignedMovers = 0) THEN\n            // Downstream station has accepted all of our movers\n            StationState := E_ApplicationStationState.eApplicationStationState_GetMovers;\n        END_IF\nEND_CASE\n</code></pre>"},{"location":"SPT_XTS/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_XTS/functionblocks.html#fb_component_xpu","title":"FB_Component_XPU","text":"<p>(<code>FINAL</code>, extends <code>FB_ComponentBase</code>, implements <code>I_XTS_Xpu</code>)</p> <p>Wrapper component for XPU TcCOM object and all of the children TcCOMs beneath.</p> <p>Serves as a central point of management for movers and their assignment to I_XTS_InfoStation and the corresponding I_XTS_ApplicationStation.</p> <p>Basic mover management functions are handled within and exposed via public methods.</p> <p>Hardware diagnostic data is automatically collected and made available by property.</p> <p>Retention of mover station assignments is optionally available via Persistent data or NOVRAM (if equipped).  Automatic restoration of retained assignments on cold start is provided.</p> <p>Example Reference Stations</p> <p>See example reference stations for example station types which extend this function block.</p> <p>Info</p> <p>See I_XTS_Xpu for more information.</p>"},{"location":"SPT_XTS/functionblocks.html#properties","title":"Properties","text":"Property Type Access Description MoverAssignmentStorageLocation E_MoverAssignmentRecoverySource RW Get/Set the location, if any, for retention of mover station assignments PartCoEData ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsPartsPerXpu] OF ARRAY[1..TcIoXtsEnvironmentParameterList.MaxModulesPerPart] OF ST_AT2xxxAllCoEData R Get diagnostic data from XPU/Hardware State E_XTSState R Get the current state of the XPU Stations ARRAY[0..TcIoXtsEnvironmentParameterList.MaxXtsInfoServer * TcIoXtsEnvironmentParameterList.MaxXtsInfoStation] OF I_XTS_ApplicationStation RW Get/Set interface pointers to assign application stations to InfoStations <p>Zero-based arrays</p> <p>For internal purposes, many arrays in this library are zero-based.  However, index 0 is never to be used.  Always start at index 1.</p>"},{"location":"SPT_XTS/functionblocks.html#methods","title":"Methods","text":"Method Return Type Access Description ClearMoverAssignments BOOL PUBLIC Returns <code>TRUE</code> if the <code>Set()</code> has been called on index <code>i</code> Disable BOOL PUBLIC Returns <code>TRUE</code> when the entire tracking register has been cleared Enable BOOL PUBLIC Clears the tracking register on index <code>i</code> and returns <code>TRUE</code> Reset BOOL PUBLIC Sets the tracking register on index <code>i</code> and returns <code>TRUE</code>"},{"location":"SPT_XTS/functionblocks.html#clearmoverassignments","title":"ClearMoverAssignments","text":"<p><code>METHOD PUBLIC ClearMoverAssignments : BOOL</code></p> <p>If enabled, mover station assignments are constantly being collected and persisted internally within the XPU component.  This method allows you to clear these assignments.</p> <p>Upon the next execution of <code>Reset()</code> the XPU component will automatically assign all movers to the next station in the positive direction whose configuration has the <code>IsAQueueStation</code> flag set.</p>"},{"location":"SPT_XTS/functionblocks.html#disable","title":"Disable","text":"<p><code>METHOD PUBLIC Disable : BOOL</code></p> <p>Disables all mover axes and dissolved the collision avoidance group.</p>"},{"location":"SPT_XTS/functionblocks.html#enable","title":"Enable","text":"<p><code>METHOD PUBLIC Enable : BOOL</code></p> <p>Enables all mover axes and adds them to the collision avoidance group.  Enables the collision avoidance group.</p>"},{"location":"SPT_XTS/functionblocks.html#reset","title":"Reset","text":"<p><code>METHOD PUBLIC Reset : BOOL</code></p> <p>Disables all movers, clears any group/mover faults.  If the mover station assignment recovery process has not yet been performed, or <code>ClearMoverAssignments()</code> was previously called, the XPU component will automatically assign all movers to the next station in the positive direction whose configuration has the <code>IsAQueueStation</code> flag set.</p>"},{"location":"SPT_XTS/functionblocks.html#fb_moverqueue","title":"FB_MoverQueue","text":"<p>Helper function block that holds a buffer of I_XTS_Mover for use by applications stations.  Assignment of movers from one station to the next happens internal to the XPU.  Application stations should use the properties listed below to gain access to specific movers for motion commands.</p>"},{"location":"SPT_XTS/functionblocks.html#properties_1","title":"Properties","text":"Property Type Access Description Count UDINT R Returns the number of I_XTS_Mover currently in the buffer FirstMover I_XTS_Mover R Returns an interface pointer to the first mover in the buffer LastMover I_XTS_Mover R Returns an interface pointer to the last mover in the buffer MoverIDs ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsMoversPerXpu] OF UDINT R Returns the mover IDs of all mover currently in the buffer Queue ARRAY[0..TcIoXtsEnvironmentParameterList.MaxXtsMoversPerXpu] OF I_XTS_Mover R Returns an array of interface pointers representing all movers in the buffer"},{"location":"SPT_XTS/functionblocks.html#methods_1","title":"Methods","text":"Method Return Type Access Description Clear BOOL PUBLIC Clears all movers from the buffer Dequeue null PUBLIC Returns <code>TRUE</code> when the first mover in the buffer has been removed Enqueue BOOL PUBLIC Returns <code>TRUE</code> when a mover has been added to the buffer (FIFO) <p>These methods are used internally!</p> <p>The methods listed above are called internally by the XPU and should never need to be called by application stations!</p>"},{"location":"SPT_XTS/functionblocks.html#fb_trackingregister_movers","title":"FB_TrackingRegister_Movers","text":"<p>Helper function block used to track different operations performed on movers.</p> <p>Why would I want this?</p> <p>The calling pattern for motion methods on movers is \"returns <code>TRUE</code> when the command has been accepted\".  This is not the same as \"command complete\".</p> <p>Take for example a collection of movers you want to move to a position on the track.  Calling <code>MoveAbsoluteCA()</code> on all of them simultaneously will return <code>TRUE</code> right away (assuming they were all ready to move) but they won't finish at the same time.  So we need some mechanism to call the command on all of the movers until it is accepted by all and then wait for the movement to be complete in a separate state.  This function block serves that purpose.</p>"},{"location":"SPT_XTS/functionblocks.html#properties_2","title":"Properties","text":"Property Type Access Description NumberCompleted UDINT R Returns the number of movers that <code>Set()</code> has been called for"},{"location":"SPT_XTS/functionblocks.html#methods_2","title":"Methods","text":"Method Return Type Access Description Check BOOL PUBLIC Returns <code>TRUE</code> if the <code>Set()</code> has been called on index <code>i</code> Clear BOOL PUBLIC Returns <code>TRUE</code> when the entire tracking register has been cleared Reset BOOL PUBLIC Clears the tracking register on index <code>i</code> and returns <code>TRUE</code> Set BOOL PUBLIC Sets the tracking register on index <code>i</code> and returns <code>TRUE</code>"},{"location":"SPT_XTS/functionblocks.html#fb_xts_stationbase","title":"FB_XTS_StationBase","text":"<p>(abstract, extends <code>FB_PackML_BaseModule</code>, implements <code>I_XTS_ApplicationStation</code>)</p> <p>Provides a basic implementation of I_XTS_ApplicationStation.  Being <code>ABSTRACT</code>, this function block must be extended and cannot be instantiated directly.  The default behavior can be overridden by its descendants.</p> <p>Example Reference Stations</p> <p>See example reference stations for example station types which extend this function block.</p>"},{"location":"SPT_XTS/functionblocks.html#properties_3","title":"Properties","text":"Property Type Access Description NumberOfAssignedMovers UDINT R Returns the number of movers currently assigned to this station NumberOfStops UDINT R Returns the number stop positions for this station StopPositions REFERENCE TO ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsStopPositionsPerStation] OF LREAL R Returns all stop position locations <p>Stop Positions cannot be commanded as-is!</p> <p>Stop Positions as defined by the XTS Configurator are relative to the Start Position of the station.  This Start Position is relative to the datum of the assigned Part.  Move commands require positions that are relative to the Track that the mover is assigned to. </p> <p></p> <p>In order to tranform a station Stop Position into a usable Track position use <code>GetStopPosition()</code>.</p> <pre><code>//Get the track position of the first stop position\nStopPosition := GetStopPosition(StopPositions[1]);\n\n//Send the last mover in line there\nIF MoverQueue.LastMover.MoveAbsoluteCA(StopPosition, TRUE, FALSE) THEN\n    //Do stuff\nEND_IF\n</code></pre>"},{"location":"SPT_XTS/functionblocks.html#methods_3","title":"Methods","text":"Method Return Type Access Description GetMovers BOOL PROTECTED Requests movers from upstream neighbor and commands each to its respective Stop Position.  Returns <code>TRUE</code> when <code>NumberOfAssignedMovers</code> = <code>NumberOfStops</code> and all movers are in position GetStopPosition LREAL PROTECTED Returns the corresponding Track position for a given stop position"},{"location":"SPT_XTS/functionblocks.html#default-behavior","title":"Default Behavior","text":"<p>The descendants of this function block are meant to be registered as Equipment Modules with a Machine Module and thus implement the PackML state machine.  Not all PackML states are required for basic station operation.  The states where custom logic was implemented are described below.</p> <p>PackML</p> <p>See SPT_Base_Types for more information.</p>"},{"location":"SPT_XTS/functionblocks.html#resetting","title":"Resetting","text":"<p>Determines if any movers have already been assigned to this station and commands them to move to their respective stop position.  When all movers have arrived at their stop positions, the state is complete.</p>"},{"location":"SPT_XTS/functionblocks.html#stopping","title":"Stopping","text":"<p>Waits for all assigned movers to be stopped, after which the state is complete.  This state does not command a stop.  Rather, it allows any in-progress move commands to complete.</p>"},{"location":"SPT_XTS/functionblocks.html#execute","title":"Execute","text":"<p>Descendants of this base function block should implement their own logic in <code>Execute()</code>.  No logic is provided in this base function block.</p>"},{"location":"SPT_XTS/globals.html","title":"Globals/Parameters","text":""},{"location":"SPT_XTS/globals.html#parameters","title":"Parameters","text":""},{"location":"SPT_XTS/globals.html#parameters_xts","title":"Parameters_XTS","text":"Parameter Type Default Description ALLOW_UNLINKED_MOVER_NC_AXES BOOL FALSE Allows internal FB_XTS_Mover FBs to skip checking for linked NC axes during initialization ENABLE_DEBUG_TRACING BOOL FALSE Allow debug messages to be emitted to trace log STATIONCOLOR_DEFAULT_GETMOVERS E_Colors_ARGB E_Colors_ARGB.Yellow XTS Viewer station color during GetMovers state STATIONCOLOR_DEFAULT_INPROCESS E_Colors_ARGB E_Colors_ARGB.Red XTS Viewer station color during InProcess state STATIONCOLOR_DEFAULT_RELEASEMOVERS E_Colors_ARGB E_Colors_ARGB.Green XTS Viewer station color during ReleaseMovers state <p>XPU generates a lot of trace messages</p> <p><code>FB_Component_XPU</code> generates a great deal of trace messages when <code>ENABLE_DEBUG_TRACING</code> is <code>TRUE</code>.  Eventually (after many thousands of messages) this can cause instability in XAE/Visual Studio due in part to the Errors List window also receiving these messages.</p> <p>These trace messages are very helpful for debugging systems but should be disabled in production.</p>"},{"location":"SPT_XTS/globals.html#gvls","title":"GVLs","text":""},{"location":"SPT_XTS/globals.html#xts","title":"XTS","text":"<pre><code>{attribute 'qualified_only'}\nVAR_GLOBAL\n    Environment              : Tc3_XTS_Utility.FB_TcIoXtsEnvironment;\n    XTSEnvironmentConfig     : ST_XtsEnvironmentConfiguration := (bEnableInitXPU := TRUE, bEnableInitCaGroup := TRUE, bEnableInitInfoServer := TRUE);\n    InitializationInProgress : BOOL;\n    InitializationComplete   : BOOL;\n    XPUCount                 : UINT;\n    XPUOIDs                  : REFERENCE TO ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsProcessingUnits] OF OTCID;\n    InfoServerCount          : UINT;\n    InfoServerOIDs           : REFERENCE TO ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsInfoServer] OF OTCID;\n    InfoStationCounts        : ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsInfoServer] OF UDINT;\n    ipInfoServer             : ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsInfoServer] OF I_TcIoXtsInfoServer;\n    ipInfoStations           : ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsInfoServer, 1..TcIoXtsEnvironmentParameterList.MaxXtsInfoStation] OF I_TcIoXtsInfoServerInfoStation;\n    CAGroupCount             : UINT;\n    CAGroupOIDs              : REFERENCE TO ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsCaGroup] OF OTCID;\nEND_VAR\n</code></pre> <p>Note</p> <p>See also: FB_TcIoXtsEnvironment, ST_XtsEnvironmentConfiguration, I_TcIoXtsInfoServer, I_TcIoXtsInfoServerInfoStation.</p> <p>Do not modify these variables!</p> <p>The variables in the <code>XTS</code> GVL are used internally by <code>FB_Component_XPU</code>.  Changing the values of any of these variables will only end in disaster or at best instability.</p>"},{"location":"SPT_XTS/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_XTS/interfaces.html#i_xts_applicationstation","title":"I_XTS_ApplicationStation","text":"<p>Application Stations are the function blocks that hold the actual logic of a machine station.  They are responsible for positioning movers and performing any other operations on the part(s) being conveyed.</p> <p>Application Stations are linked 1:1 via interface pointer to their respective InfoStations.  In other words, an Application Station can only have one linked InfoStation and vice-versa.  This link is bi-directional.</p> <p>InfoStations take care of the intricacies of buffer management, station relationships, etc. and actually contain the buffer of movers within them.  Application Stations work alongside InfoStations at the application layer to signal when their particular logic and sequence can either accommodate a new mover or is finished with a mover under its control.</p>"},{"location":"SPT_XTS/interfaces.html#properties","title":"Properties","text":"Property Type Access Description CanAcceptMover BOOL R Get whether or not this station can accept an additional mover into its buffer CanReleaseMover BOOL R Get whether or not this station can release a mover from its buffer Config ST_XTSStationConfig RW Get/Set configuration struction for this station InfoStation I_XTS_InfoStation W Set the InfoStation that is associated with this station Name STRING R Get the friendly name of this station TrackOID OTCID R Get the OID of the Track that this station is associated with"},{"location":"SPT_XTS/interfaces.html#i_xts_infostation","title":"I_XTS_InfoStation","text":"<p>An InfoStation is a zone which spans a part, as defined by a Start and End position along the part.  Additionally, stop positions can be defined relative to the Start position.</p> <p>Warning</p> <p>Note that the XTS configuration tool allows for the specification of multiple parts in an InfoStation definition.  This is not supported by this component/framework.  An InfoStation can only be defined across a single part.</p>"},{"location":"SPT_XTS/interfaces.html#properties_1","title":"Properties","text":"Property Type Access Description ApplicationStation I_XTS_ApplicationStation RW Get/Set interface pointer to the function block who is controlling the application logic for this InfoStation Color E_Colors_ARGB RW Get/Set the color of this InfoStation that will be displayed on the XTS Viewer MoverQueue REFERENCE TO FB_MoverQueue R Get a reference to the buffer of movers currently under this station's control NumberOfStops UDINT R Get the number of stop positions defined for this station StopPositions REFERENCE TO ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsStopPositionsPerStation] OF LREAL R Get a reference to the stop positions defined for this station"},{"location":"SPT_XTS/interfaces.html#methods","title":"Methods","text":"Method Return Type Description GetMover BOOL Returns <code>TRUE</code> when a mover has been successfully passed from the upstream neighbor station and is ready to be commanded by this station GetPositionOnTrack LREAL Given a position on a relative to the start position of this station, along with the <code>OTCID</code> of the desired track, returns the corresponding track position"},{"location":"SPT_XTS/interfaces.html#i_xts_mover","title":"I_XTS_Mover","text":"<p>(extends <code>I_CyclicFB</code>)</p> <p>Defines basic required functionality for an XTS mover.</p>"},{"location":"SPT_XTS/interfaces.html#properties_2","title":"Properties","text":"Property Type Access Description Axis REFERENCE TO AXIS_REF R Returns an AXIS_REF for use in external motion functions, etc. LimitBipolarCurrent BOOL RW Enable/Disable the limiting of current to the mover MoverID UDINT R Returns the mover index on its associated XTS Override LREAL RW Get/Set axis override (100.0 = 100%) Station I_XTS_ApplicationStation RW Get/Set the station to which this mover has been assigned"},{"location":"SPT_XTS/interfaces.html#dynamics","title":"Dynamics","text":"Property Type Access Description Acceleration LREAL RW Get/Set acceleration input to motion functions Deceleration LREAL RW Get/Set deceleration input to motion functions Jerk LREAL RW Get/Set jerk input to motion functions Velocity LREAL RW Get/Set velocity input to motion functions (exception: <code>MoveVelocity()</code>)"},{"location":"SPT_XTS/interfaces.html#feedback","title":"Feedback","text":"Property Type Access Description ActualAcceleration LREAL R Get actual acceleration of axis ActualPosition LREAL R Get actual position of axis ActualPositionModulo LREAL R Get actual modulo position of axis ActualTorque LREAL R Get actual torque of axis ActualVelocity LREAL R Get actual velocity of axis PositionLag LREAL R Get position lag of axis SetAcceleration LREAL R Get setpoint acceleration of axis SetPosition LREAL R Get setpoint position of axis SetPositionModulo LREAL R Get setpoint modulo position of axis SetVelocity LREAL R Get setpoint velocity of axis"},{"location":"SPT_XTS/interfaces.html#status","title":"Status","text":"Property Type Access Description Enabled BOOL R Axis is enabled InPosition BOOL R Axis is within target position window Stopped BOOL R Axis is not moving"},{"location":"SPT_XTS/interfaces.html#methods_1","title":"Methods","text":"Method Return Type Description Disable BOOL Disable axis Enable BOOL Enable axis JoinGroup BOOL Join the associated collision avoidance group LeaveGroup BOOL Leave the associated collision avoidance group MoveAbsoluteCA BOOL Initiate an absolute move with collision avoidance MoveRelativeCA BOOL Initiate a relative move with collision avoidance Reset BOOL Reset axis Stop BOOL Commands a stop of the mover"},{"location":"SPT_XTS/interfaces.html#i_xts_part","title":"I_XTS_Part","text":"<p>A part is a collection of XTS motor modules, typically segmented by infeed modules.  An XTS system is comprised of one or many parts.</p>"},{"location":"SPT_XTS/interfaces.html#properties_3","title":"Properties","text":"Property Type Access Description Name STRING R Returns the object name of the associated XPU part ReadyToEnable BOOL R Returns <code>TRUE</code> if the <code>DriveState</code> of the part is satisfactory for enabling movers"},{"location":"SPT_XTS/interfaces.html#i_xts_stationneighbor","title":"I_XTS_StationNeighbor","text":"<p>Don't use this directly</p> <p>Internal type used to keep track of upstream/downstream relationships between InfoStations.  This should not be used at the application level and is only documented here for clarity.</p>"},{"location":"SPT_XTS/interfaces.html#properties_4","title":"Properties","text":"Property Type Access Description StationName STRING R Returns friendly name of the associated Application Station"},{"location":"SPT_XTS/interfaces.html#methods_2","title":"Methods","text":"Method Return Type Description GiveMover BOOL Returns <code>TRUE</code> when an InfoStation has successfully passed a mover to its downstream neighbor TakeMover BOOL Returns <code>TRUE</code> when an InfoStation accepts a mover into its buffer"},{"location":"SPT_XTS/interfaces.html#i_xts_track","title":"I_XTS_Track","text":"<p>A track is a logical path that XTS movers exist on.  Tracks are defined by including one or many parts.  The datum point of a track is typically the upstream side of the first part.  Multiple tracks can exist in the same XTS system, and can also overlap.  This means that a the same physical position on an XTS system can be a different track position, depending on how the track is defined.  A mover can only be assigned to one track at a time.  Collision avoidance is performed according to track.  This means that given a lineup of stationary movers, all avoiding collision, if a mover is assigned to a different track the movers upstream of that one will advance and collide.</p>"},{"location":"SPT_XTS/interfaces.html#properties_5","title":"Properties","text":"Property Type Access Description IsClosed BOOL R Returns <code>TRUE</code> if the track is a closed loop Length LREAL R Returns the length of the part in millimeters Name STRING R Returns the object name of the track"},{"location":"SPT_XTS/interfaces.html#methods_3","title":"Methods","text":"Method Return Type Description GetTrackPositionByPart LREAL Given a position on a particular part, along with the <code>OTCID</code> of the part, returns the corresponding track position"},{"location":"SPT_XTS/interfaces.html#i_xts_xpu","title":"I_XTS_Xpu","text":""},{"location":"SPT_XTS/interfaces.html#properties_6","title":"Properties","text":"Property Type Access Description InSimulationMode BOOL R Returns <code>TRUE</code> if the XPU driver is set to run in simulation mode"},{"location":"SPT_XTS/interfaces.html#methods_4","title":"Methods","text":"Method Return Type Description GetPositionOnTrack LREAL Given a position on a particular part, along with the <code>OTCID</code> of part &amp; track, returns the corresponding track position GiveMover BOOL Returns <code>TRUE</code> when a mover has been added to the <code>MoverQueue</code> of the requesting station"},{"location":"SPT_XTS/quickstart.html","title":"QuickStart","text":""},{"location":"SPT_XTS/quickstart.html#intial-setup","title":"Intial Setup","text":"<p>This process can take a few different paths, but the end goal is to have the XTS system laid out in your TwinCAT project.  This layout should include:</p> <ul> <li>Realtime Configuration</li> <li>PLC Task</li> <li>XTS Task(s) (250us cycle time)</li> <li>Proper core allocation</li> <li>TcCOM Objects</li> <li>XPU - Parts, Tracks, Movers</li> <li>InfoServer - Station definitions including stop positions</li> <li>NC Configuration</li> <li>Collision Avoidance TcCOM object<ul> <li>Track length matching XPU track length</li> </ul> </li> <li>Mover Axes with correct SoftDrive configuration/links</li> <li>EtherCAT configuration</li> <li>Motor modules as children of EtherCAT masters</li> <li>Masters may be disabled for execution in simulation mode</li> <li>Distributed clock timing checked and correct</li> </ul>"},{"location":"SPT_XTS/quickstart.html#simulation-mode","title":"Simulation Mode","text":"<p>Hardware configuration for simulation mode can be easily built using the XTS Simulation Builder:</p> <p></p>"},{"location":"SPT_XTS/quickstart.html#no-twincat-project-loaded","title":"No TwinCAT project loaded","text":"<p>The simulation builder includes template options for quickly building common track layouts:</p> <p></p>"},{"location":"SPT_XTS/quickstart.html#adding-xts-to-existing-twincat-project","title":"Adding XTS to existing TwinCAT project","text":"<p>Use Modify Projects to build a track layout by hand and add it to an existing TwinCAT project</p> <p></p>"},{"location":"SPT_XTS/quickstart.html#hardware-in-hand","title":"Hardware in hand","text":"<p>If running on real XTS hardware, refer to InfoSys for detailed configuration steps.</p>"},{"location":"SPT_XTS/quickstart.html#ca-group-configration","title":"CA Group Configration","text":"<p>A collision avoidance group object must be added to the NC configuration:</p> <p></p> <p></p> <p>CA group must be parameterized.  Rail length must match the actual XTS track length:</p> <p></p>"},{"location":"SPT_XTS/quickstart.html#application-programming","title":"Application Programming","text":"<p>This example will use the SPT PackML method of machine organization and programming but realize that there is no formal requirement for PackML to be involved to use the XTS component.</p> <p>The steps below assume the following configuration, but can be easily adapted to suit a variety of different setups:  - 3000 MM oval-shaped track using clothoid ends  - 1 Part  - 1 Track  - 10 Movers  - 4 Stations    - Station 1: Queue    - Station 2: SimpleStation, 1 stop position    - Station 3: Queue    - Station 4: SimpleStation, 1 stop position</p> <p></p> <p>Add a PLC project and reference the required libraries:   - SPT Base Types   - SPT XTS   - Tc3_XTS_Utility   - Tc3_PackML_V2</p>"},{"location":"SPT_XTS/quickstart.html#fb_machine","title":"FB_Machine","text":"<p>Create a function block <code>FB_Machine</code> which extends <code>FB_PackML_BaseModule</code>.  Instantiate <code>FB_Component_XPU</code> and station equipment modules.  Create configuration structures for each of the stations as well as an array for assigning the station instances to the XPU during initialization.  This function block will serve as our Machine Module, or the root of the control structure. <pre><code>FUNCTION_BLOCK FB_Machine EXTENDS FB_PackML_BaseModule\nVAR\n    XPU : FB_Component_XPU := (Name := 'XPU 1', Stations := ipStations, MoverAssignmentStorageLocation := E_MoverAssignmentRecoverySource.eMoverAssignmentRecoverySource_NoBackup);\n    Station1 : FB_XTS_QueueStation;\n    Station2 : FB_XTS_SimpleStation;\n    Station3 : FB_XTS_QueueStation;\n    Station4 : FB_XTS_SimpleStation;\n    StationConfig_Station1 : ST_XTSStationConfig;\n    StationConfig_Station2 : ST_XTSStationConfig;\n    StationConfig_Station3 : ST_XTSStationConfig;\n    StationConfig_Station4 : ST_XTSStationConfig;\n    ipStations : ARRAY[0..TcIoXtsEnvironmentParameterList.MaxXtsInfoServer * TcIoXtsEnvironmentParameterList.MaxXtsInfoStation] OF I_XTS_ApplicationStation;\nEND_VAR\n</code></pre></p>"},{"location":"SPT_XTS/quickstart.html#method-overrides","title":"Method Overrides","text":"<p>We must have an initialize routine to make some assignments and to perform some setup tasks.  <code>FB_PackML_BaseModule</code> already has an <code>Initialize()</code> method that we can override.  We must also override some of the acting state methods of <code>FB_PackML_BaseModule</code> in order to modify the default behavior.  <code>Aborting()</code>, <code>Clearing()</code>, <code>Resetting()</code>, and <code>Stopping()</code> should be overriden.</p>"},{"location":"SPT_XTS/quickstart.html#initialize","title":"Initialize()","text":"<p>Basic parameterization and assignment are done in the <code>Initialize()</code> method.  Note in particular the lines <code>StationConfig_Station1.IsAQueueStation := TRUE;</code> and <code>StationConfig_Station3.IsAQueueStation     := TRUE;</code>.  These bits indicate to the XPU component that during a cold start with no mover assignment backup data source, stations 1 and 3 are candidates for serving as a starting point where movers will be sorted and assigned to.</p> <pre><code>METHOD PROTECTED Initialize : BOOL;\n\nipComponents[1] := XPU;\nipSubModules[1] := Station1;\nipSubModules[2] := Station2;\nipSubModules[3] := Station3;\nipSubModules[4] := Station4;\nipStations[1] := Station1;\nipStations[2] := Station2;\nipStations[3] := Station3;\nipStations[4] := Station4;\nStation1.Config := StationConfig_Station1;\nStation2.Config := StationConfig_Station2;\nStation3.Config := StationConfig_Station3;\nStation4.Config := StationConfig_Station4;\nStationConfig_Station1.IsAQueueStation   := TRUE;\nStationConfig_Station1.Dynamics.Velocity := 500;\nStationConfig_Station2.Dynamics.Velocity := 500;\nStationConfig_Station3.IsAQueueStation   := TRUE;\nStationConfig_Station3.Dynamics.Velocity := 500;\nStationConfig_Station4.Dynamics.Velocity := 500;\nXPU.Stations := ipStations;\nInitialize := SUPER^.Initialize();\n</code></pre>"},{"location":"SPT_XTS/quickstart.html#aborting","title":"Aborting()","text":"<p>The default behavior of <code>Aborting()</code> does not know anything about the XPU's <code>Disable()</code> method.  Here we first disable the XPU component if required and then allow the base <code>Aborting()</code> method to continue with the rest of the equipment modules and components. <pre><code>METHOD PROTECTED Aborting\n\nCASE SequenceState OF\n    0:\n        IF XPU.State = E_XTSState.eXTSState_Enabled OR XPU.State = E_XTSState.eXTSState_Disabling THEN\n            IF XPU.Disable() THEN\n                SequenceState := SequenceState + 10;\n            END_IF\n        ELSIF XPU.State = E_XTSState.eXTSState_Disabled OR XPU.State = E_XTSState.eXTSState_Error THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    10:\n        SUPER^.Aborting();\nEND_CASE\n</code></pre></p>"},{"location":"SPT_XTS/quickstart.html#clearing","title":"Clearing()","text":"<p>The default behavior of <code>Clearing()</code> does not call <code>Reset()</code> on components that do not have errors.  Because mover assignment recovery is triggered by the <code>Reset()</code> method, we must make sure it is called regardless of error state.  Default behavior can resume afterward. <pre><code>METHOD PROTECTED Clearing\n\nCASE SequenceState OF \n    0:\n        IF XPU.Reset() THEN\n            SequenceState := SequenceState + 10;    \n        END_IF\n\n    10:\n        SUPER^.Clearing();\nEND_CASE\n</code></pre></p>"},{"location":"SPT_XTS/quickstart.html#resetting","title":"Resetting()","text":"<p>Similar to the case of <code>Aborting()</code> above, the XPU has an <code>Enable()</code> method which builds the CA group, enables mover axis, etc. which much be called.</p> <pre><code>METHOD PROTECTED Resetting\n\nCASE SequenceState OF\n    0:\n        IF XPU.Enable() THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    10:\n        SUPER^.Resetting();\nEND_CASE\n</code></pre>"},{"location":"SPT_XTS/quickstart.html#stopping","title":"Stopping()","text":"<p>The default behavior of <code>Stopping()</code> only handles issuing a stop command to equipment modules.  We also want to disable the XPU component after reaching this state.</p> <pre><code>METHOD PROTECTED Stopping\nVAR\n  i : UDINT;\n  SubModulesReady : BOOL := TRUE;\nEND_VAR\n</code></pre> <pre><code>CASE SequenceState OF\n    0:\n        // Send stop command to all sub modules\n        FOR i := 1 TO NumberOfSubModules DO\n            ipSubModules[i].StateCommand := ePMLCommand_Stop;\n        END_FOR\n\n        FOR i := 1 TO NumberOfSubModules DO\n            SubModulesReady := SubModulesReady AND (ipSubModules[i].CurrentState = ePMLState_Stopped OR ipSubModules[i].CurrentState = ePMLState_Aborted);\n        END_FOR\n\n        IF SubModulesReady THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    10:\n        IF XPU.Disable() THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    20:\n        IF XPU.State = E_XTSState.eXTSState_Disabled THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    30:\n        StateComplete();\nEND_CASE\n</code></pre>"},{"location":"SPT_XTS/quickstart.html#main-pou","title":"MAIN POU","text":"<p>Now that we have created our machine module and overridden the default behavior of <code>FB_PackML_BaseModule</code> as required, we can introduce it into the cyclic program logic.</p> <p>The default PLC project template in TwinCAT XAE will create a <code>MAIN</code> POU and attach it to the default PlcTask.  This will be the entry point for our program.</p> <p>Instantiate <code>FB_Machine</code> and <code>FB_ControlSource</code>.  <code>FB_ControlSource</code> simply provides a quick and easy means for commanding the machine module to different states and provides feedback on current machine module status.</p> <pre><code>PROGRAM MAIN\nVAR\n    Machine : FB_Machine;\n    ControlSource : FB_ControlSource;\nEND_VAR\n</code></pre> <p>We must attach <code>ControlSource</code> to the machine module so that it knows what it's controlling.  We must also make the calls to <code>CyclicLogic()</code> for both our machine module and <code>ControlSource</code>:</p> <pre><code>IF _TaskInfo[1].FirstCycle THEN\n    Machine.RegisterExternalController(ControlSource);\nEND_IF\n\nMachine.CyclicLogic();\nControlSource.CyclicLogic();\n</code></pre>"},{"location":"SPT_XTS/quickstart.html#linking-process-data-to-plc","title":"Linking process data to PLC","text":"<p>At this point you should be able to build the PLC project with no errors.  Doing this also will let XAE know of any allocated variables (<code>%I*</code>/<code>%Q*</code>) in our program and allow us to link them to other TwinCAT modules.</p>"},{"location":"SPT_XTS/quickstart.html#nc-axes","title":"NC Axes","text":"<p>The XPU component contains an array of mover function blocks (upper bound set in the <code>Tc3_XTS_Utility</code> library <code>TcIoXtsEnvironmentParameterList.MaxXtsMoversPerXpu</code>).  These must be linked to our NC axes.  Note the array starts at index 0 for internal reasons, but mover 0 is never actually used.  Start at mover 1.</p> <p></p>"},{"location":"SPT_XTS/quickstart.html#ca-group","title":"CA Group","text":"<p>The XPU component also contains the necessary <code>AXES_GROUP_REF</code> which must be linked to our collision avoidance group TcCOM object.</p> <p></p> <p></p>"},{"location":"SPT_XTS/quickstart.html#tracing","title":"Tracing","text":"<p>The XPU component emits a great deal of debug information to the Event Logger, which can be useful for debug.  By default, this messaging is turned off in order to not bog down the development environment.  During the initial commissioning it can be re-enabled through the library parameters:</p> <p></p>"},{"location":"SPT_XTS/quickstart.html#results","title":"Results","text":"<p>At this point we should be able to activate the configuration, restart in Run Mode, and Login to the PLC.  Adding the following variable to the Watch window gives us convenient place to monitor the progress.</p> <p></p> <p><code>ControlSource.MainPMLControl_Simplified.ResetPressed</code>, <code>StartPressed</code>, and <code>StopPressed</code> can be toggled manually to advance through the PackML states.  These can also be tied to buttons on a Visualization or TwinCAT HMI screen, for example.</p>"},{"location":"SPT_XTS/quickstart.html#varying-configurations","title":"Varying Configurations","text":"<p>In this example, Stations 2 &amp; 4 are type <code>FB_XTS_SimpleStation</code>.  This example function block includes a property <code>SimulatedProcessTime</code> which controls a timer which begins counting when all movers have arrived at their stop position(s) and upon expiration signals the station to release all movers to the next neighbor.  A variety of processes can be simulated by varying this time setpoint, as well as defining multiple stop positions using the XTS Configurator.</p> <p>Stations 1 &amp; 3 are type <code>FB_XTS_QueueStation</code>.  This example function block includes a property <code>MaxNumberOfMovers</code> which controls how many movers are allowed into the station's mover buffer at one time.  Note that even though the XTS Configurator allows for multiple stop positions to be defined, <code>FB_XTS_QueueStation</code> will only command movers to move to the first stop position.  Any other stop positions are ignored.</p>"},{"location":"SPT_XTS/quickstart.html#custom-stations","title":"Custom Stations","text":"<p><code>FB_XTS_SimpleStation</code> and <code>FB_XTS_QueueStation</code> are provided for reference only.  They represent the most basic types of station logic that may be part of an XTS system.  Custom station logic can be implemented from scratch, or with help from inheriting <code>FB_XTS_StationBase</code>.  <code>FB_XTS_StationBase</code> is an <code>ABSTRACT</code> function block which contains the basic components that one would use to implement a custom station type.</p>"},{"location":"SPT_XTS/stationprogrammingnotes.html","title":"GetMovers()","text":"<p>InfoStations (internal to XPU component) are responsible for delivering to the Application Station a buffer of interface pointers which the Application Station then uses to command motion.  The template function block <code>FB_XTS_StationBase</code> includes a method <code>GetMovers()</code>, which handles basic mover acquisition and positioning.</p> <p>An explanation of this base logic may be useful to those seeking to develop custom station types.</p>"},{"location":"SPT_XTS/stationprogrammingnotes.html#the-code","title":"The Code","text":"<pre><code>CASE SequenceState OF\n    0:\n        IF (NumberOfAssignedMovers &lt; NumberOfStops) THEN\n            SequenceState := SequenceState + 10;\n        ELSE\n            SequenceState := 40;\n        END_IF\n\n    10:\n        IF ipInfoStation.GetMover() THEN\n            // Ask for a new mover          \n            SequenceState := SequenceState + 10;\n        END_IF\n\n    20:\n        //Make sure we don't page fault\n        IF MoverQueue.LastMover &lt;&gt; 0 THEN\n            // Call new mover to this station--station positions go front-to-back\n            StopPosition := StopPositions[NumberOfStops - (NumberOfAssignedMovers - 1)];\n            StopPosition := GetStopPosition(StopPosition);\n            IF MoverQueue.LastMover.MoveAbsoluteCA(StopPosition, TRUE, FALSE) THEN\n                SequenceState := SequenceState + 10;\n            END_IF\n        END_IF\n\n    30:\n        // Make sure we have the correct number of movers\n        IF NumberOfAssignedMovers = NumberOfStops THEN\n            SequenceState := SequenceState + 10;\n        ELSE\n            SequenceState := 10;\n        END_IF\n\n    40:\n        //Wait for all movers to arrive at their assigned positions\n        MoverTracker.Clear();\n        ipMovers := MoverQueue.Queue;\n        FOR i := 1 TO NumberOfStops DO\n            IF ipMovers[i] &lt;&gt; 0 THEN\n                IF NOT ipMovers[i].Busy THEN\n                    StopPosition := StopPositions[NumberOfStops - (i - 1)];\n                    StopPosition := GetStopPosition(StopPosition);\n                    IF ipMovers[i].IsMoverInPosition(StopPosition) THEN\n                        MoverTracker.Set(i);\n                    END_IF\n                END_IF\n            END_IF\n        END_FOR\n\n        IF MoverTracker.NumberCompleted = NumberOfStops THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    50:\n        SequenceState := 0;\n        GetMovers     := TRUE;\nEND_CASE\n</code></pre>"},{"location":"SPT_XTS/stationprogrammingnotes.html#the-intent","title":"The Intent","text":"<p>A basic <code>CASE</code> state machine is executed, with an inner loop (states 0-30) repeating until the correct number of movers (based on Stop Positions configured for the InfoStation) have been acquired.  The logic waits until all movers have arrived at their assigned positions before returning <code>TRUE</code>, indicating to the caller that all movers have arrived.</p> <ul> <li>State 0 - Check the buffer depth to see if we need another mover</li> <li><code>NumberOfAssignedMovers</code> is a property that returns the number of movers in the buffer <code>MoverQueue</code>.  <code>MoverQueue</code> is actually a pointer to the buffer function block that lives inside the <code>FB_XTS_InfoStation</code> that is assigned to this <code>I_XTS_ApplicationStation</code> (via the <code>InfoStation</code> property).  This pointer is managed automatically.</li> <li><code>NumberOfStops</code> is a property that returns the number of stop positions that have been defined for this InfoStation</li> <li>State 10 - Ask our InfoStation to get another mover</li> <li>The <code>GetMover()</code> method will return <code>TRUE</code> when a new mover has been added to the buffer</li> <li>This logic is handled internally in the XPU component</li> <li>Movers will only be passed from the upstream <code>I_XTS_ApplicationStation</code> if that station has set its <code>CanReleaseMover</code> property to <code>TRUE</code></li> <li>State 20 - Get the next stop position and send our new mover there<ul> <li><code>StopPositions</code> is an array of positions that corresponds to the Stop Positions set for this InfoStation</li> <li>Stop Positions as set using the XTS configurator are relative to the Start Position of the station!</li> <li>They must be transformed according to the Track this <code>I_XTS_ApplicationStation</code> is assigned to</li> <li>Most configurations only include one track</li> <li><code>GetStopPosition()</code> will calculate the position on the track that we will then command our new mover to</li> </ul> </li> <li>State 30 - Check to see if we have the required number of movers</li> <li>State 40 - Wait for all movers to arrive at their assigned position<ul> <li><code>MoverTracker</code> is a simple way of tracking which movers have successfully completed a task so that we don't issue the same command many times</li> <li><code>ipMovers</code> gets a copy of the <code>MoverQueue.Queue</code>.  This is required so that we can index against the array of <code>I_XTS_Mover</code></li> <li>If <code>I_XTS_Mover.Busy</code> is set, a command is still in process</li> <li>We get the track position for each Stop Position and check that the mover's actual position is within an acceptable range</li> <li>This range is defined as Stop Position +/- NC Parameter Target Position Window</li> </ul> </li> </ul> <p>    - State 50 - Dead Scan to return true and clean up the state machine</p>"},{"location":"SPT_XTS/stationprogrammingnotes.html#queue-logic","title":"Queue Logic","text":"<p><code>FB_XTS_QueueStation</code> overrides the above state machine and removes the 'in position' checks.</p> <pre><code>CASE SequenceState OF\n    0:\n        //Don't combine this with state 20 -- there is a dead scan for method cleanup/returns\n        IF CanAcceptMover THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    10:\n        IF ipInfoStation.GetMover() THEN\n            // Ask for a new mover      \n            SequenceState := SequenceState + 10;\n        END_IF\n\n    20:\n        //Make sure we don't page fault\n        IF MoverQueue.LastMover &lt;&gt; 0 THEN\n            // Call new mover to this station--use only stop position 1\n            StopPosition := StopPositions[1];\n            StopPosition := GetStopPosition(StopPosition);\n            IF MoverQueue.LastMover.MoveAbsoluteCA(StopPosition, TRUE, FALSE) THEN\n                SequenceState := 0;\n            END_IF\n        ELSE\n            SequenceState := 0;\n        END_IF\nEND_CASE\n</code></pre>"}]}